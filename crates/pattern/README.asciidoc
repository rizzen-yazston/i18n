= i18n_pattern
Rizzen Yazston

== Pattern parser and formatter

The parser handles the parsing of string tokens into an Abstract Syntax Tree (AST), checking the grammar of patterns is valid. The parser only does the syntactic analysis of the supplied Token vector.

The formatter takes the AST that was generated by the parser and constructs a string template for values to be substituted into. The formatter also does the semantic analysis of the grammar. Once a string template has been constructed, it can be used multiple times by simply supplying new placeholder values when executing the format() method. Depending on the placeholder type of the pattern, a suitable selection of the available data types can be used, these include the basic `String`, integers, unsigned integers and floats. In addition to these special ICU4X types are supported such as `FixedDecimal`, `Date`, `Time` and `DateTime` structs.

See `pattern strings.asciidoc` in `docs` of `pattern` crate for the pattern formatting specification.

== Cargo.toml

```
[dependencies]
icu_locid = "1.1.0"
i18n_icu-rizzen-yazston = "0.5.0"
i18n_lstring-rizzen-yazston = "0.5.0"
i18n_lexer-rizzen-yazston = "0.5.0" # Needed for Token, TokenType
tree-rizzen-yazston = "0.3.0"

[dependencies.icu_provider]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde", "deserialize_bincode_1" ]

[dependencies.icu_properties]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.icu_segmenter]
version = "0.8.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.icu_plurals]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.fixed_decimal]
version = "0.5.2"
# Needed for BufferProvider
features = [ "ryu" ]

[dependencies.icu_decimal]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.icu_calendar]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.icu_datetime]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]
```

== Examples

```
use i18n_icu::IcuDataProvider;
use i18n_lexer::{Token, TokenType, Lexer};
use i18n_pattern::{ parse, NodeType, Formatter, FormatterError, PlaceholderValue };
use icu_testdata::buffer;
use icu_provider::serde::AsDeserializingBufferProvider;
use icu_locid::Locale;
use std::collections::HashMap;
use std::rc::Rc;
use std::error::Error;

fn pattern_plural() -> Result<(), Box<dyn Error>> {
    let buffer_provider = buffer();
    let data_provider = buffer_provider.as_deserializing();
    let icu_data_provider = Rc::new( IcuDataProvider::try_new( &data_provider )? );
    let mut lexer = Lexer::try_new( &icu_data_provider )?;
    let tokens = lexer.tokenise(
        "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
        &vec![ '{', '}', '`', '#' ]
    );
    let tree = parse( tokens.0 )?;
    let locale: Rc<Locale> = Rc::new( "en-ZA".parse()? );
    let language_tag = Rc::new( locale.to_string() );
    let mut formatter = Formatter::try_new( &icu_data_provider, &language_tag, &locale, &tree )?;
    let mut values = HashMap::<String, PlaceholderValue>::new();
    values.insert(
        "dogs_number".to_string(),
        PlaceholderValue::Unsigned( 3 )
    );
    let result = formatter.format( &values )?;
    assert_eq!( result.as_str(), "There are 3 dogs in the park.", "Strings must be the same." );
    Ok( () )
}

```
