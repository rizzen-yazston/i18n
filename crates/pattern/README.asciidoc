= i18n_pattern
Rizzen Yazston

== Pattern parser and formatter

The parser handles the parsing of string tokens into an Abstract Syntax Tree (AST), checking the grammar of patterns is valid. The parser only does the syntactic analysis of the supplied Token vector.

The formatter takes the AST that was generated by the parser and constructs a string template for values to be substituted into. The formatter also does the semantic analysis of the grammar. Once a string template has been constructed, it can be used multiple times by simply supplying new placeholder values when executing the format() method. Depending on the placeholder type of the pattern, a suitable selection of the available data types can be used, these include the basic `String`, integers, unsigned integers and floats. In addition to these special ICU4X types are supported such as `FixedDecimal`, `Date`, `Time` and `DateTime` structs.

See `pattern strings.asciidoc` in `docs` of `pattern` crate for the pattern formatting specification.

== Cargo.toml

```
[dependencies]
icu_locid = "1.1.0"
i18n_lstring-rizzen-yazston = "0.4.0"
i18n_lexer-rizzen-yazston = "0.4.0" # Needed for Token, TokenType
tree-rizzen-yazston = "0.3.0"

[dependencies.icu_provider]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde", "deserialize_bincode_1" ]

[dependencies.icu_plurals]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.fixed_decimal]
version = "0.5.2"
# Needed for BufferProvider
features = [ "ryu" ]

[dependencies.icu_decimal]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.icu_calendar]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]

[dependencies.icu_datetime]
version = "1.1.0"
# Needed for BufferProvider
features = [ "serde" ]
```

== Examples

```
use icu_provider::prelude::*;
use icu_locid::Locale;
use std::rc::Rc;
use i18n_lexer::{ Token, TokenType, Lexer };
use icu_testdata::buffer;
use i18n_pattern::{ parse, NodeType, Formatter, FormatterError, PlaceholderValue };
use std::collections::HashMap;
use std::error::Error;

fn pattern_plural() -> Result<(), Box<dyn Error>> {
    let buffer_provider = Box::new( buffer() );
    let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
    let tokens = lexer.tokenise(
        "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
        &vec![ '{', '}', '`', '#' ]
    );
    let tree = parse( tokens ).expect( "Failed to parse tokens." );
    let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
    let language_tag = Rc::new( locale.to_string() );
    let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
    let mut values = HashMap::<String, PlaceholderValue>::new();
    values.insert(
        "dogs_number".to_string(),
        PlaceholderValue::Unsigned( 3 )
    );
    let result = formatter.format( &buffer_provider, &values )?;
    assert_eq!( result.as_str(), "There are 3 dogs in the park.", "Strings must be the same." );
    Ok( () )
}
```
