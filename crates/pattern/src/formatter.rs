// This file is part of `i18n_pattern-rizzen-yazston` crate. For the terms of use, please see the file
// called `LICENSE-BSD-3-Clause` at the top level of the `i18n_pattern-rizzen-yazston` crate.

// Outstanding: Command (to be done during or after `message` crate), experimental ICU4X components and options.
// Feature option: language tag wrapping

//! The formatter takes the Abstract Syntax Tree (AST) that was generated by the parser and constructs a string
//! template for values to be substituted into. The formatter also does the semantic analysis of the grammar. Once a
//! string template has been constructed, it can be used multiple times by simply supplying new placeholder values when
//! executing the `format()` method. Depending on the placeholder type of the pattern, a suitable selection of the
//! available data types can be used, these include the basic `String`, integers, unsigned integers and floats. In
//! addition to these special ICU4X types are supported such as `FixedDecimal`, `Date`, `Time` and `DateTime` structs.
//! 
//! See `pattern strings.asciidoc` in `docs` of `pattern` crate for the pattern formatting specification.
//!
//! # Examples
//!
//! ```
//! use icu_provider::prelude::*;
//! use icu_locid::Locale;
//! use std::rc::Rc;
//! use i18n_lexer::{ Token, TokenType, Lexer };
//! use icu_testdata::buffer;
//! use i18n_pattern::{ parse, NodeType, Formatter, FormatterError, PlaceholderValue };
//! use std::collections::HashMap;
//! 
//! fn format_string() -> Result<(), FormatterError> {
//!     let buffer_provider = Box::new( buffer() );
//!     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
//!     let tokens = lexer.tokenise(
//!         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
//!         &vec![ '{', '}', '`', '#' ]
//!     );
//!     let tree = parse( tokens ).expect( "Failed to parse tokens." );
//!     let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
//!     let language_tag = Rc::new( locale.to_string() );
//!     let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
//!     let mut values = HashMap::<String, PlaceholderValue>::new();
//!     values.insert(
//!         "dogs_number".to_string(),
//!         PlaceholderValue::Unsigned( 3 )
//!     );
//!     let result = formatter.format( &buffer_provider, &values )?;
//!     assert_eq!(
//!         result.as_str(),
//!         "There are 3 dogs in the park.",
//!         "Strings must be the same."
//!     );
//!     Ok( () )
//! }
//! match format_string() {
//!     Err( error ) => {
//!         println!( "Error: {}", error );
//!         assert!( false );
//!         return;
//!     },
//!     Ok( _ ) => {}
//! };
//! ```

use i18n_error::{ ErrorMessage, ErrorPlaceholderValue };
use crate::*;
use i18n_lexer::Token;
use i18n_lstring::LString;
use tree::Tree;
use icu_provider::prelude::*;
use icu_locid::Locale;
use icu_plurals::{PluralCategory, PluralRules};
use icu_decimal::{FixedDecimalFormatter, options};
use fixed_decimal::{FixedDecimal, DoublePrecision, SignDisplay};
use icu_calendar::{
    types::{Time, IsoHour, IsoMinute, IsoSecond, NanoSecond},
    DateTime, Date, Iso
};
use icu_datetime::{
    options::length::{Bag, Date as DateLength, Time as TimeLength},
    DateTimeFormatter, DateFormatter, TimeFormatter
};
use std::collections::HashMap;
use std::rc::Rc;
use std::str::FromStr;
use std::error::Error; // Experimental in `core` crate.
use core::fmt::{ Debug, Display, Formatter as FmtFormatter, Result as FmtResult };

pub struct Formatter {
    language_tag: Rc<String>,
    locale: Rc<Locale>,
    patterns: HashMap<String, Vec<PatternPart>>,
    numbers: Vec<String>,
    selectors: Vec<HashMap<String, String>>,
}

impl Formatter {
    /// Creates a Formatter for a language string using parsing results.
    /// During the creation of the formatter for the supplied Tree, the semantic analyse is done.
    ///
    /// # Examples
    ///
    /// ```
    /// use icu_provider::prelude::*;
    /// use std::rc::Rc;
    /// use icu_locid::Locale;
    /// use i18n_lexer::{Token, TokenType, Lexer};
    /// use icu_testdata::buffer;
    /// use i18n_pattern::{parse, NodeType, Formatter, FormatterError, PlaceholderValue};
    /// use std::collections::HashMap;
    /// 
    /// fn format_string() -> Result<(), FormatterError> {
    ///     let buffer_provider = Box::new( buffer() );
    ///     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
    ///     let tokens = lexer.tokenise(
    ///         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
    ///         &vec![ '{', '}', '`', '#' ]
    ///     );
    ///     let tree = parse( tokens ).expect( "Failed to parse tokens." );
    ///     let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
    ///     let language_tag = Rc::new( locale.to_string() );
    ///     let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
    ///     let mut values = HashMap::<String, PlaceholderValue>::new();
    ///     values.insert(
    ///         "dogs_number".to_string(),
    ///         PlaceholderValue::Unsigned( 3 )
    ///     );
    ///     let result = formatter.format( &buffer_provider, &values )?;
    ///     assert_eq!(
    ///         result.as_str(),
    ///         "There are 3 dogs in the park.",
    ///         "Strings must be the same."
    ///     );
    ///     Ok( () )
    /// }
    /// match format_string() {
    ///     Err( error ) => {
    ///         println!( "Error: {}", error );
    ///         assert!( false );
    ///         return;
    ///     },
    ///     Ok( _ ) => {}
    /// };
    /// ```
    pub fn try_new(
        language_tag: &Rc<String>,
        locale: &Rc<Locale>,
        tree: &Tree,
    ) -> Result<Self, FormatterError> {
        let mut patterns = HashMap::<String, Vec<PatternPart>>::new();
        patterns.insert( "_".to_string(), Vec::<PatternPart>::new() ); // Insert empty main pattern.
        let mut numbers = Vec::<String>::new();
        let mut selectors = Vec::<HashMap<String, String>>::new();
        if tree.len() == 0 {
            return Ok( Formatter {
                language_tag: Rc::clone( &language_tag ),
                locale: Rc::clone( &locale ),
                patterns,
                numbers,
                selectors,
            } );
        }
        let option_selectors = OptionSelectors {
            valid_plurals: vec![ "zero", "one", "two", "few", "many",  "other" ],
            calendars: vec![ "gregorian", "buddhist", "japanese", "ethiopian", "indian", "coptic" , "iso" ],
        };
        if !check_node_type( tree, 0, NodeType::Root ) {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Tree root is not a Root node." ),
                identifier: String::from( "i18n_pattern/root_node" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        }

        // Process substrings first if present.
        if let Ok( last ) = tree.last( 0 ) {
            if check_node_type( tree, last, NodeType::NamedGroup ) {
                let Ok( named_strings ) = tree.children( last ) else {
                    return Err( FormatterError::InvalidNode( ErrorMessage {
                        string: String::from( "Could not retrieve children for NamedGroup." ),
                        identifier: String::from( "i18n_pattern/named_group_children" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) );
                };
                for named in named_strings.iter() {
                    let mut pattern = Vec::<PatternPart>::new();
                    if !check_node_type( tree, *named, NodeType::NamedString ) {
                        return Err( FormatterError::InvalidNode( ErrorMessage {
                            string: String::from( "NamedString node was not found." ),
                            identifier: String::from( "i18n_pattern/named_string_not_found" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    }
    
                    // Get NamedString identifier and check it is not already present.
                    let Ok( first ) = tree.first( *named ) else {
                        return Err( FormatterError::InvalidNode( ErrorMessage {
                            string: String::from( "First child of NamedString node not found." ),
                            identifier: String::from( "i18n_pattern/named_string_first" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    if !check_node_type( tree, first, NodeType::Identifier ) {
                        return Err( FormatterError::InvalidNode( ErrorMessage {
                            string: String::from( "Identifier node was not found." ),
                            identifier: String::from( "i18n_pattern/identifier_not_found" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    }
                    let Ok(identifier_data ) = tree.data_ref( first ) else {
                        return Err( FormatterError::NodeData( ErrorMessage {
                            string: String::from( "Could not retrieve data for Identifier node." ),
                            identifier: String::from( "i18n_pattern/identifier_data" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    let Some( identifier_token ) =
                        identifier_data.first().unwrap().downcast_ref::<Rc<Token>>()
                    else {
                        return Err( FormatterError::NodeData( ErrorMessage {
                            string: String::from( "Failed to retrieve token for Identifier node." ),
                            identifier: String::from( "i18n_pattern/identifier_token" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    if patterns.contains_key( identifier_token.string.as_str() ) {
                        return Err( FormatterError::Unique( ErrorMessage {
                            string: String::from( "NamedString identifiers must be unique and not `_`." ),
                            identifier: String::from( "i18n_pattern/unique_named_string" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    }
    
                    // Got NamedString identifier
                    let Ok( last ) = tree.last( *named ) else {
                        return Err( FormatterError::InvalidNode( ErrorMessage {
                            string: String::from( "Last child of NamedString node not found." ),
                            identifier: String::from( "i18n_pattern/named_string_last" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    if !check_node_type( tree, last, NodeType::String ) {
                        return Err( FormatterError::InvalidNode( ErrorMessage {
                            string: String::from( "String node was not found." ),
                            identifier: String::from( "i18n_pattern/string_not_found" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    }
                    let Ok( children ) = tree.children( last ) else {
                        return Err( FormatterError::InvalidNode( ErrorMessage {
                            string: String::from( "Could not retrieve children for String." ),
                            identifier: String::from( "i18n_pattern/string_children" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    for child in children.iter() {
                        if check_node_type( tree, *child, NodeType::Text ) {
                            part_text( &mut pattern, tree, *child )?;
                        } else if check_node_type( tree, *child, NodeType::NumberSign ) {
                            let len = numbers.len();
                            numbers.push( String::new() );
                            pattern.push( PatternPart::NumberSign( len ) );
                        } else if check_node_type( tree, *child, NodeType::Pattern ) {
                            part_pattern(
                                &mut pattern, 
                                &patterns, 
                                tree,
                                *child,
                                &mut selectors,
                                &option_selectors,
                                locale,
                            )?;
                        } else if check_node_type( tree, *child, NodeType::Command ) {
                            // TODO: create a method for Command pattern as both NamedString and main String have it.
                        } else {
                            return Err( FormatterError::InvalidNode( ErrorMessage {
                                string: String::from( "Invalid node found in String." ),
                                identifier: String::from( "i18n_pattern/string_invalid_node" ),
                                values: HashMap::<String, ErrorPlaceholderValue>::new(),
                            } ) );
                        }
                    }
                    patterns.insert( identifier_token.string.as_str().to_string(), pattern );
                }
            }
        };

        // Now process main string.
        let mut pattern = Vec::<PatternPart>::new();
        let Ok( first ) = tree.first( 0 ) else {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "First child of Root node not found." ),
                identifier: String::from( "i18n_pattern/root_node_first." ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        if !check_node_type( tree, first, NodeType::String ) {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "String node was not found." ),
                identifier: String::from( "i18n_pattern/string_not_found" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        }
        let Ok( children ) = tree.children( first ) else {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Could not retrieve children for String." ),
                identifier: String::from( "i18n_pattern/string_children" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        for child in children.iter() {
            if check_node_type( tree, *child, NodeType::Text ) {
                part_text( &mut pattern, tree, *child )?;
            } else if check_node_type( tree, *child, NodeType::Pattern ) {
                part_pattern(
                    &mut pattern, 
                    &patterns, 
                    tree,
                    *child,
                    &mut selectors,
                    &option_selectors,
                    locale,
                )?;
            } else if check_node_type( tree, *child, NodeType::Command ) {
                // TODO: create a method for Command pattern as both NamedString and main String have it.
            } else {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Invalid node found in String." ),
                    identifier: String::from( "i18n_pattern/string_invalid_node" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
        }
        patterns.insert( "_".to_string(), pattern );
        Ok( Formatter {
            language_tag: Rc::clone( &language_tag ),
            locale: Rc::clone( &locale ),
            patterns,
            numbers,
            selectors,
        } )
    }

    /// Format the language string with supplied values.
    ///
    /// # Examples
    ///
    /// ```
    /// use icu_provider::prelude::*;
    /// use std::rc::Rc;
    /// use icu_locid::Locale;
    /// use i18n_lexer::{Token, TokenType, Lexer};
    /// use icu_testdata::buffer;
    /// use i18n_pattern::{parse, NodeType, Formatter, FormatterError, PlaceholderValue};
    /// use std::collections::HashMap;
    /// 
    /// fn format_string() -> Result<(), FormatterError> {
    ///     let buffer_provider = Box::new( buffer() );
    ///     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
    ///     let tokens = lexer.tokenise(
    ///         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
    ///         &vec![ '{', '}', '`', '#' ]
    ///     );
    ///     let tree = parse( tokens ).expect( "Failed to parse tokens." );
    ///     let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
    ///     let language_tag = Rc::new( locale.to_string() );
    ///     let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
    ///     let mut values = HashMap::<String, PlaceholderValue>::new();
    ///     values.insert(
    ///         "dogs_number".to_string(),
    ///         PlaceholderValue::Unsigned( 3 )
    ///     );
    ///     let result = formatter.format( &buffer_provider, &values )?;
    ///     assert_eq!(
    ///         result.as_str(),
    ///         "There are 3 dogs in the park.",
    ///         "Strings must be the same."
    ///     );
    ///     Ok( () )
    /// }
    /// match format_string() {
    ///     Err( error ) => {
    ///         println!( "Error: {}", error );
    ///         assert!( false );
    ///         return;
    ///     },
    ///     Ok( _ ) => {}
    /// };
    /// ```
    pub fn format(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, PlaceholderValue>
    ) -> Result<LString, FormatterError> {
        if self.patterns.get( "_" ).unwrap().len() == 0 {
            return Ok( LString::new( String::new(), &self.language_tag ) );
        }
        let pattern_string = self.format_pattern(
            buffer_provider,
            values,
            &"_".to_string(),
        )?;
        Ok( LString::new( pattern_string, &self.language_tag ) )
    }

    /// This `format_error()` functions exactly as `format()`, except only accepts the smaller `ErrorPlaceholderValue`
    /// enum instead of the full `PlaceholderValue` enum. `ErrorPlaceholderValue` has no dependencies other than `core`
    /// and `std` crates, thus can be used in libraries and applications where multilingual message system is optional.
    ///
    /// # Examples
    ///
    /// ```
    /// // Note: The string being formatted is not an actual error message, showing that `format_error()` is the same
    /// // internally as `format()`.
    /// use icu_provider::prelude::*;
    /// use std::rc::Rc;
    /// use icu_locid::Locale;
    /// use i18n_lexer::{Token, TokenType, Lexer};
    /// use icu_testdata::buffer;
    /// use i18n_pattern::{parse, NodeType, Formatter, FormatterError};
    /// use i18n_error::ErrorPlaceholderValue;
    /// use std::collections::HashMap;
    /// 
    /// fn format_string() -> Result<(), FormatterError> {
    ///     let buffer_provider = Box::new( buffer() );
    ///     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
    ///     let tokens = lexer.tokenise(
    ///         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
    ///         &vec![ '{', '}', '`', '#' ]
    ///     );
    ///     let tree = parse( tokens ).expect( "Failed to parse tokens." );
    ///     let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
    ///     let language_tag = Rc::new( locale.to_string() );
    ///     let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
    ///     let mut values = HashMap::<String, ErrorPlaceholderValue>::new();
    ///     values.insert(
    ///         "dogs_number".to_string(),
    ///         ErrorPlaceholderValue::Unsigned( 3 )
    ///     );
    ///     let result = formatter.format_error( &buffer_provider, &values )?;
    ///     assert_eq!(
    ///         result.as_str(),
    ///         "There are 3 dogs in the park.",
    ///         "Strings must be the same."
    ///     );
    ///     Ok( () )
    /// }
    /// match format_string() {
    ///     Err( error ) => {
    ///         println!( "Error: {}", error );
    ///         assert!( false );
    ///         return;
    ///     },
    ///     Ok( _ ) => {}
    /// };
    /// ```
    pub fn format_error(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, ErrorPlaceholderValue>
    ) -> Result<LString, FormatterError> {

        // Transform to PlaceholderValue
        let mut new_values = HashMap::<String, PlaceholderValue>::new();
        for ( key, value ) in values.iter() {
            new_values.insert(
                key.to_string(),
                match value {
                    ErrorPlaceholderValue::Float( number ) => PlaceholderValue::Float( *number ),
                    ErrorPlaceholderValue::Integer( number ) => PlaceholderValue::Integer( *number ),
                    ErrorPlaceholderValue::String( string ) => PlaceholderValue::String( string.to_string() ),
                    ErrorPlaceholderValue::Unsigned( number ) => PlaceholderValue::Unsigned( *number )
                }
            );
        }

        if self.patterns.get( "_" ).unwrap().len() == 0 {
            return Ok( LString::new( String::new(), &self.language_tag ) );
        }
        let pattern_string = self.format_pattern(
            buffer_provider,
            &new_values,
            &"_".to_string(),
        )?;
        Ok( LString::new( pattern_string, &self.language_tag ) )
    }

    /// Returns the locale used in creating the formatter.
    pub fn locale( &self ) -> &Rc<Locale> {
        &self.locale
    }

    /// Returns the language tag used in creating the formatter.
    pub fn language( &self ) -> &Rc<String> {
        &self.language_tag
    }

    // Internal methods

    fn part_ref( &self, string: &String, index: usize ) -> Option<&PatternPart> {
        if let Some( pattern ) = self.patterns.get( string ) {
            if let Some( part ) = pattern.get( index ) {
                return Some( part );
            }
        }
        None
    }

    fn format_pattern(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, PlaceholderValue>,
        named: &String
    ) -> Result<String, FormatterError> {
        let mut string = String::new();
        let mut _len = 0usize;
        {
            let Some( pattern ) = self.patterns.get( named ) else {
                return Err( FormatterError::Format( ErrorMessage {
                    string: String::from( "Failed to retrieve named string pattern." ),
                    identifier: String::from( "i18n_pattern/named_string_pattern" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            };
            _len = pattern.len();
        }
        let mut i = 0usize;
        while i < _len {
            let Some( part ) = self.part_ref( named, i ) else {
                return Err( FormatterError::Format( ErrorMessage {
                    string: String::from( "Could not retrieve part of pattern." ),
                    identifier: String::from( "i18n_pattern/pattern_part" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            };
            match part {
                PatternPart::Text( text ) => {
                    string.push_str( text.as_str() );
                },
                PatternPart::PatternString( placeholder ) => {
                    let Some( value ) = values.get( placeholder ) else {
                        return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Placeholder value is not found for PatternString." ),
                            identifier: String::from( "i18n_pattern/pattern_string_placeholder" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    match value {
                        PlaceholderValue::String( value ) => string.push_str( value ),
                        PlaceholderValue::LString( value) => string.push_str( value.as_str() ),
                        _ => return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Invalid value type provided for PatternString." ),
                            identifier: String::from( "i18n_pattern/pattern_string_value" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) )
                    }
                },
                PatternPart::PatternDecimal{
                    placeholder,
                    sign,
                    group
                } => {
                    let Some( value ) = values.get( placeholder ) else {
                        return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Placeholder value is not found for PatternDecimal." ),
                            identifier: String::from( "i18n_pattern/pattern_decimal_placeholder" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    let data_locale = DataLocale::from( Rc::as_ref( &self.locale ) );
                    let mut options: options::FixedDecimalFormatterOptions = Default::default();
                    if group.is_some() {
                        options.grouping_strategy = group.unwrap();
                    }
                    let Ok( fdf ) = FixedDecimalFormatter::try_new_with_buffer_provider(
                        buffer_provider,
                        &data_locale,
                        options,
                    ) else {
                        return Err( FormatterError::IcuError( ErrorMessage {
                            string: String::from( "Failed to load decimal formatting information for locale." ),
                            identifier: String::from( "i18n_pattern/fixed_decimal_load" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    match value {
                        PlaceholderValue::FixedDecimal( number ) => {
                            let fixed_decimal = &mut number.clone();
                            if sign.is_some() {
                                fixed_decimal.apply_sign_display( sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        PlaceholderValue::Unsigned( number ) => {
                            let mut fixed_decimal = FixedDecimal::from( *number );
                            if sign.is_some() {
                                fixed_decimal.apply_sign_display( sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        PlaceholderValue::Integer( number ) => {
                            let mut fixed_decimal = FixedDecimal::from( *number );
                            if sign.is_some() {
                                fixed_decimal.apply_sign_display( sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        PlaceholderValue::Float( number ) => {
                            // Precision is always Floating, for other precisions options use PlaceholderFixedDecimal
                            let Ok( mut fixed_decimal ) = FixedDecimal::try_from_f64(
                                *number, DoublePrecision::Floating
                            ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Failed to created FixedDecimal for PlaceholderFloat." ),
                                    identifier: String::from( "i18n_pattern/fixed_decimal_from_float" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            if sign.is_some() {
                                fixed_decimal.apply_sign_display( sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        _ => return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Invalid value type provided for PatternDecimal." ),
                            identifier: String::from( "i18n_pattern/pattern_decimal_value" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) )
                    }
                },
                PatternPart::PatternDateTime{
                    placeholder,
                    length_date,
                    length_time,
                    calendar,
                } => {
                    // TODO: add more options as they become non-experimental.
                    // TODO: implement hour for Time/DateTime when no longer experimental
                    let Some( value ) = values.get( placeholder ) else {
                        return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Placeholder value is not found for PatternDateTime." ),
                            identifier: String::from( "i18n_pattern/pattern_date_time_placeholder" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    let length_date = match length_date {
                        None => DateLength::Medium,
                        Some( result ) => *result
                    };
                    let length_time = match length_time {
                        None => TimeLength::Medium,
                        Some( result ) => *result
                    };
                    let options = Bag::from_date_time_style(
                        length_date,
                        length_time,
                    );
                    let data_locale = match calendar {
                        None => DataLocale::from( Rc::as_ref( &self.locale ) ),
                        Some( locale ) => DataLocale::from( locale )
                    };
                    match value {
                        PlaceholderValue::DateTime( date_time) => {
                            let Ok( dtf ) = DateTimeFormatter::try_new_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                                options.into(),
                            ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Failed to load date-time information for locale." ),
                                    identifier: String::from( "i18n_pattern/date_time_load" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            let Ok( date_string ) = dtf.format_to_string( &date_time.to_any() ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Could not format date-time for locale." ),
                                    identifier: String::from( "i18n_pattern/format_date_time" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            string.push_str( date_string.as_str() );
                        },
                        PlaceholderValue::Date( date ) => {
                            let Ok( df ) = DateFormatter::try_new_with_length_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                                length_date,
                            ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Failed to load date-time information for locale." ),
                                    identifier: String::from( "i18n_pattern/date_time_load" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            let Ok( date_string ) = df.format_to_string( &date.to_any() ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Could not format date for locale." ),
                                    identifier: String::from( "i18n_pattern/format_date" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            string.push_str( date_string.as_str() );
                        },
                        PlaceholderValue::Time( time ) => {
                            let Ok( tf ) = TimeFormatter::try_new_with_length_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                                length_time,
                            ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Failed to load date-time information for locale." ),
                                    identifier: String::from( "i18n_pattern/date_time_load" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            let date_string = tf.format_to_string( time );
                            string.push_str( date_string.as_str() );
                        },
                        PlaceholderValue::String( value ) => {
                            let date_time_strings: Vec<&str> = value.split( 'T' ).collect();
                            if date_time_strings.len() == 2 {
                                if date_time_strings[ 0 ] == "" {

                                    // time only
                                    let time: Time = decompose_iso_time( date_time_strings[ 1 ] )?;
                                    let Ok( tf ) =
                                        TimeFormatter::try_new_with_length_with_buffer_provider(
                                        buffer_provider,
                                        &data_locale,
                                        length_time,
                                    ) else {
                                        return Err( FormatterError::IcuError( ErrorMessage {
                                            string: String::from( "Failed to load date-time information for locale." ),
                                            identifier: String::from( "i18n_pattern/date_time_load" ),
                                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                        } ) );
                                    };
                                    let date_string = tf.format_to_string( &time );
                                    string.push_str( date_string.as_str() );
                                } else {

                                    // date and time
                                    let date: Date<Iso> = decompose_iso_date( date_time_strings[ 0 ] )?;
                                    let time: Time = decompose_iso_time( date_time_strings[ 1 ] )?;
                                    let date_time = DateTime::<Iso>::new( date, time );
                                    let Ok( dtf ) = DateTimeFormatter::try_new_with_buffer_provider(
                                        buffer_provider,
                                        &data_locale,
                                        options.into(),
                                    ) else {
                                        return Err( FormatterError::IcuError( ErrorMessage {
                                            string: String::from( "Failed to load date-time information for locale." ),
                                            identifier: String::from( "i18n_pattern/date_time_load" ),
                                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                        } ) );
                                    };
                                    let Ok( date_string ) = dtf.format_to_string( &date_time.to_any() ) else {
                                        return Err( FormatterError::IcuError( ErrorMessage {
                                            string: String::from( "Could not format date-time for locale." ),
                                            identifier: String::from( "i18n_pattern/format_date_time" ),
                                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                        } ) );
                                    };
                                    string.push_str( date_string.as_str() );
                                }
                            } else {

                                // date only
                                let date: Date<Iso> = decompose_iso_date( date_time_strings[ 0 ] )?;
                                let Ok( df ) = DateFormatter::try_new_with_length_with_buffer_provider(
                                    buffer_provider,
                                    &data_locale,
                                    length_date,
                                ) else {
                                    return Err( FormatterError::IcuError( ErrorMessage {
                                        string: String::from( "Failed to load date-time information for locale." ),
                                        identifier: String::from( "i18n_pattern/date_time_load" ),
                                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                    } ) );
                                };
                                let Ok( date_string ) = df.format_to_string( &date.to_any() ) else {
                                    return Err( FormatterError::IcuError( ErrorMessage {
                                        string: String::from( "Could not format date for locale." ),
                                        identifier: String::from( "i18n_pattern/format_date" ),
                                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                    } ) );
                                };
                                string.push_str( date_string.as_str() );
                            }
                        },
                        _ => return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Invalid value type provided for PatternDecimal." ),
                            identifier: String::from( "i18n_pattern/pattern_decimal_value" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) )
                    }
                },
                PatternPart::PatternComplex{
                    placeholder,
                    complex,
                    selectors,
                } => {
                    let Some( value ) = values.get( placeholder ) else {
                        return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Placeholder value is not found for PatternComplex." ),
                            identifier: String::from( "i18n_pattern/pattern_complex_placeholder" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    let selectors_index = selectors;
                    let data_locale = DataLocale::from( Rc::as_ref( &self.locale ) );
                    match complex {
                        ComplexType::Plural => {
                            let Ok( plurals ) = PluralRules::try_new_cardinal_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                            ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Failed to load plural rules information for locale." ),
                                    identifier: String::from( "i18n_pattern/plural_load" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            match value {
                                PlaceholderValue::FixedDecimal( number ) => self.find_number_sign(
                                    buffer_provider,
                                    values,
                                    &mut string,
                                    number,
                                    plurals,
                                    &data_locale,
                                    *selectors_index,
                                )?,
                                PlaceholderValue::Unsigned( number ) => {
                                    let fixed_decimal = FixedDecimal::from( *number );
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        *selectors_index,
                                    )?;
                                },
                                PlaceholderValue::Integer( number ) => {
                                    let fixed_decimal = FixedDecimal::from( *number );
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        *selectors_index,
                                    )?;
                                },
                                PlaceholderValue::Float( number ) => {
                                    let Ok( fixed_decimal ) = FixedDecimal::try_from_f64(
                                        *number, DoublePrecision::Floating
                                    ) else {
                                        return Err( FormatterError::IcuError( ErrorMessage {
                                            string: String::from(
                                                "Failed to created FixedDecimal for PlaceholderFloat."
                                            ),
                                            identifier: String::from( "i18n_pattern/fixed_decimal_from_float" ),
                                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                        } ) );
                                    };
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        *selectors_index,
                                    )?;
                                },
                                _ => return Err( FormatterError::Format( ErrorMessage {
                                    string: String::from( "Invalid value type provided for PatternOrdinal." ),
                                    identifier: String::from( "i18n_pattern/pattern_ordinal_value" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) )
                            }
                        },
                        ComplexType::Ordinal => {

                            // Only positive integers and zero are allowed.
                            let Ok( plurals ) = PluralRules::try_new_ordinal_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                            ) else {
                                return Err( FormatterError::IcuError( ErrorMessage {
                                    string: String::from( "Failed to load plural rules information for locale." ),
                                    identifier: String::from( "i18n_pattern/plural_load" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) );
                            };
                            match value {
                                PlaceholderValue::Unsigned( number ) => {
                                    let fixed_decimal = FixedDecimal::from( *number );
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        *selectors_index,
                                    )?;
                                },
                                _ => return Err( FormatterError::Format( ErrorMessage {
                                    string: String::from( "Invalid value type provided for PatternOrdinal." ),
                                    identifier: String::from( "i18n_pattern/pattern_ordinal_value" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) )
                            }
                        },
                        ComplexType::Select => {
                            match value {
                                PlaceholderValue::String( value ) => {
                                    self.select(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        value,
                                        *selectors_index,
                                    )?;
                                },
                                PlaceholderValue::LString( value ) => {

                                    // Locale is not used, and LSring is just treated as String for the selector
                                    self.select(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &value.as_str().to_string(),
                                        *selectors_index,
                                    )?;
                                },
                                _ => return Err( FormatterError::Format( ErrorMessage {
                                    string: String::from( "Invalid value type provided for PatternOrdinal." ),
                                    identifier: String::from( "i18n_pattern/pattern_ordinal_value" ),
                                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                                } ) )
                            }
                        },
                    }
                },
                PatternPart::NumberSign( index ) => {
                    let Some( number_string ) = self.numbers.get( *index ) else {
                        return Err( FormatterError::Format( ErrorMessage {
                            string: String::from( "Unable to retrieve reference for NumberSign index." ),
                            identifier: String::from( "i18n_pattern/number_size_reference" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) );
                    };
                    string.push_str( number_string.as_str() );
                }
            }
            i += 1;
        }
        Ok( string )
    }

    fn find_number_sign(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, PlaceholderValue>,
        string: &mut String,
        fixed_decimal: &FixedDecimal,
        plurals: PluralRules,
        data_locale: &DataLocale,
        selectors_index: usize,
    ) -> Result<(), FormatterError> {
        let mut _named = String::new();

        // Format number using graphemes of the locale.
        let Ok( fdf ) = FixedDecimalFormatter::try_new_with_buffer_provider(
            buffer_provider,
            data_locale,
            Default::default(),
        ) else {
            return Err( FormatterError::IcuError( ErrorMessage {
                string: String::from( "Failed to load decimal formatting information for locale." ),
                identifier: String::from( "i18n_pattern/fixed_decimal_load" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        let number_string = fdf.format( fixed_decimal ).to_string();
        let category = plural_category( plurals.category_for( fixed_decimal ) ).to_string();

        // Get the named string, and locate number signs to update the string.
        {
            let Some( selectors ) = self.selectors.get( selectors_index ) else {
                return Err( FormatterError::Format( ErrorMessage {
                    string: String::from( "Index not found in selectors." ),
                    identifier: String::from( "i18n_pattern/selector_index" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            };
            let Some( named ) = selectors.get( &category ) else {
                return Err( FormatterError::Format( ErrorMessage {
                    string: String::from( "Failed to retrieve named string from selector." ),
                    identifier: String::from( "i18n_pattern/selector_named_string" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            };
            _named = named.to_string();
        }
        {
            let mut _len = 0usize;
            {
                let Some( pattern ) = self.patterns.get( &_named ) else {
                    return Err( FormatterError::Format( ErrorMessage {
                        string: String::from( "Failed to retrieve named string pattern." ),
                        identifier: String::from( "i18n_pattern/named_string_pattern" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) );
                };
                _len = pattern.len();
            }
            let mut i = 0usize;
            while i < _len {
                let mut _part: Option<&PatternPart> = None;
                {
                let Some( part ) = self.part_ref( &_named, i ) else {
                    return Err( FormatterError::Format( ErrorMessage {
                        string: String::from( "Could not retrieve part of pattern." ),
                        identifier: String::from( "i18n_pattern/pattern_part" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) );
                };
                _part = Some( part );
                }
                match _part.unwrap() {
                    PatternPart::NumberSign( index ) => self.update_number_part( *index, &number_string )?,
                    _ => {}
                }
                i += 1;
            }
        }
        let part_string = self.format_pattern(
            buffer_provider,
            values,
            &_named
        )?;
        string.push_str( part_string.as_str() );
        Ok( () )
    }

    fn select(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, PlaceholderValue>,
        string: &mut String,
        string_value: &String,
        selectors_index: usize,
    ) -> Result<(), FormatterError> {
    
        // Get the named string, and locate number signs to update the string.
        let Some( selectors ) = self.selectors.get( selectors_index ) else {
            return Err( FormatterError::Format( ErrorMessage {
                string: String::from( "Index not found in selectors." ),
                identifier: String::from( "i18n_pattern/selector_index" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        let Some( named ) = selectors.get( string_value ) else {
            return Err( FormatterError::Format( ErrorMessage {
                string: String::from( "Failed to retrieve named string from selector." ),
                identifier: String::from( "i18n_pattern/selector_named_string" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        let part_string = self.format_pattern(
            buffer_provider,
            values,
            &named.to_string(),
        )?;
        string.push_str( part_string.as_str() );
        Ok( () )
    }

    fn update_number_part( &mut self, index: usize, number_string: &String ) -> Result<(), FormatterError> {
        let Some( number_string_mut ) = self.numbers.get_mut( index ) else {
            return Err( FormatterError::Format( ErrorMessage {
                string: String::from( "Unable to retrieve reference for NumberSign index." ),
                identifier: String::from( "i18n_pattern/number_size_reference" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        *number_string_mut = number_string.to_string();
        Ok( () )
    }
}

#[derive( Debug )]
pub enum FormatterError {
    NodeData( ErrorMessage ),
    Unique( ErrorMessage ),
    InvalidNode( ErrorMessage ),
    StringParse( ErrorMessage ),
    Format( ErrorMessage ),
    IcuError( ErrorMessage ),
}

impl Error for FormatterError {}

impl Display for FormatterError {

    /// Write to the formatter the default preformatted error message.
    fn fmt( &self, formatter: &mut FmtFormatter ) -> FmtResult {
        match self {
            FormatterError::NodeData( error ) => formatter.write_str( error.string.as_str() ),
            FormatterError::Unique( error) => formatter.write_str( error.string.as_str() ),
            FormatterError::InvalidNode( error ) => formatter.write_str( error.string.as_str() ),
            FormatterError::StringParse( error ) => formatter.write_str( error.string.as_str() ),
            FormatterError::Format( error ) => formatter.write_str( error.string.as_str() ),
            FormatterError::IcuError( error ) => formatter.write_str( error.string.as_str() ),
        }
    }
}

/// Decomposes an ISO 8601 date string into a `Date<Iso>` struct.
/// 
/// Supported ISO 8601 extended and basic formats:
///   YYYY-MM-DD or YYYYMMDD
///   YYYY-MM
///   YYYY
/// where:
///   YYYY refers to a zero-padded year, range of 0000 to 9999 (1 BC to 9999 AD).
///   MM refers to a zero-padded month, range of 01 to 12, and defaults to 01 when not present.
///   DD refers to a zero-padded day, range of 01 to 31, and defaults to 01 when not present.
/// 
/// Currently ISO 8601 does not allow the YYYYMM format due to historical data using the obsolete YYMMDD format.
///
/// Supported ISO 8601 expanded formats:
///   -YYYY-MM-DD
///   -YYYY-MM
///   -YYYY
///   ±YYYYY-MM-DD
///   ±YYYYY-MM
///   ±YYYYY
/// where:
///   ± refers to either + or -.
///   YYYY refers to zero-padded year with - prefix, range of -0001 to -9999 (2 BC to 10000 BC).
///   YYYYY refers to 5 or more digits with either + or - prefix, range before -9999 (10000 BC) or after 9999.
///   MM refers to a zero-padded month, range of 01 to 12, and defaults to 01 when not present.
///   DD refers to a zero-padded day, range of 01 to 31, and defaults to 01 when not present.
///
/// ICU4X `Date` supports the year to be in the range of `-2_147_483_648` to `2_147_483_647`.
/// 
/// ISO 8601 _Week_ and _Ordinal date_ formats are not supported as there are currently no methods available for 
/// ICU4X `Date<Iso>` for creating structs using the week number or the ordinal day of the year.
pub fn decompose_iso_date( string: &str ) -> Result<Date<Iso>, FormatterError> {
    let no_plus = string.trim_start_matches( '+' );
    let mut year: i32 = 0;
    let mut month: u8 = 1;
    let mut day: u8 = 1;
    if no_plus.is_empty() {

        // no year
        let Ok( date ) = Date::try_new_iso_date( year, month, day ) else {
            return Err( FormatterError::StringParse( ErrorMessage {
                string: String::from( "Invalid date component." ),
                identifier: String::from( "i18n_pattern/parse_date_component" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        return Ok( date );
    }
    let parts: Vec<&str> = no_plus.split( '-' ).collect();
    if parts.len() == 1 {

        // YYYYMMDD or YYYY. ISO 8601 may re-add YYYYMM in the future, once most historical data has been 
        // converted from YYMMDD.
        if let Some( slice ) = parts[ 0 ].get( ..4 ) {
            match i32::from_str( slice ) {
                Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                    string: String::from( "Invalid year." ),
                    identifier: String::from( "i18n_pattern/parse_year" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) ),
                Ok( result ) => year = result
            }

            // try month
            if let Some( slice ) = parts[ 0 ].get( 4..6 ) {
                match u8::from_str( slice ) {
                    Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                        string: String::from( "Invalid month." ),
                        identifier: String::from( "i18n_pattern/parse_month" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) ),
                    Ok( result ) => month = result
                }

                // try day
                if let Some( slice ) = parts[ 0 ].get( 6..8 ) {
                    match u8::from_str( slice ) {
                        Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                            string: String::from( "Invalid day." ),
                            identifier: String::from( "i18n_pattern/parse_day" ),
                            values: HashMap::<String, ErrorPlaceholderValue>::new(),
                        } ) ),
                        Ok( result ) => day = result
                    }
                }
            }
        }
    } else {
        let mut index = 0usize;
        let mut year_string = String::new();
        if parts[ 0 ].is_empty() {

            // negative dates
            year_string.push( '-' );
            index = 1;
        }
        year_string.push_str( parts[ index ] );
        match i32::from_str( &year_string ) {
            Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                string: String::from( "Invalid year." ),
                identifier: String::from( "i18n_pattern/parse_year" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) ),
            Ok( result ) => year = result
        }

        // try month
        index += 1;
        if let Some( slice ) = parts.get( index ) {
            match u8::from_str( slice ) {
                Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                    string: String::from( "Invalid month." ),
                    identifier: String::from( "i18n_pattern/parse_month" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) ),
                Ok( result ) => month = result
            }

            // try day
            index += 1;
            if let Some( slice ) = parts.get( index ) {
                match u8::from_str( slice ) {
                    Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                        string: String::from( "Invalid day." ),
                        identifier: String::from( "i18n_pattern/parse_day" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) ),
                    Ok( result ) => day = result
                }
            }
        }
    }
    match Date::try_new_iso_date( year, month, day ) {
        Err( _ ) => Err( FormatterError::StringParse( ErrorMessage {
            string: String::from( "Invalid date component." ),
            identifier: String::from( "i18n_pattern/parse_date_component" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) ),
        Ok( result ) => Ok( result )
    }
}

/// Decomposes an ISO time string into a `Time` struct.
/// 
/// Supported ISO 8601 extended and basic formats:
///   Thh:mm:ss.nnn or Thhmmss.nnn
///   Thh:mm:ss or Thhmmss
///   Thh:mm or Thhmm
///   Thh
///   T 
/// where:
///   T refers to the time separator from date. Even though required by ISO 8601, it is optional here.
///   hh refers to a zero-padded hour, range of 00 to 24 (24 used to represent last instance of the day 24:00:00).
///   mm refers to a zero-padded minute, range of 00 to 59.
///   ss refers to a zero-padded second, range of 00 to 60 (where 60 is only used to denote an added leap second).
///   nnn refers to a nanosecond, range of 000 to 999.
/// 
/// All time components not included are treated as zero.
/// 
/// Time zones are not supported by ICU4X `Time`, thus will be ignored.
/// - time zones ( Z (for UCT 00:00), +hh:mm, -hh:mm, +hhmm, -hhmm ).
///   -00:00 or -0000 are not supported by ISO 8601.

pub fn decompose_iso_time( string: &str ) -> Result<Time, FormatterError> {
    let no_t = string.trim_start_matches( 'T' );
    let no_plus = match no_t.find( '+' ) {
        None => no_t,
        Some( pos ) => &no_t[ ..pos ]
    };
    let trimmed = match no_plus.find( '-' ) {
        None => no_plus,
        Some( pos ) => &no_plus[ ..pos ]
    };
    if trimmed.is_empty() {
        return Ok( Time::new(
            IsoHour::zero(),
            IsoMinute::zero(),
            IsoSecond::zero(),
            NanoSecond::zero()
        ) );
    }
    let mut hour = IsoHour::zero();
    let mut minute = IsoMinute::zero();
    let mut second = IsoSecond::zero();
    let mut nano = NanoSecond::zero();
    if let Some( slice ) = trimmed.get( ..2 ) {
        match IsoHour::from_str( slice ) {
            Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                string: String::from( "Invalid hour." ),
                identifier: String::from( "i18n_pattern/parse_hour" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) ),
            Ok( result ) => hour = result
        }

        // try minute
        let mut no_hour = &trimmed[ 2.. ];
        no_hour = no_hour.trim_start_matches( ':' );
        if let Some( slice ) = no_hour.get( ..2 ) {
            match IsoMinute::from_str( slice ) {
                Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                    string: String::from( "Invalid minute." ),
                    identifier: String::from( "i18n_pattern/parse_minute" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) ),
                Ok( result ) => minute = result
            }

            // try second
            let mut no_minute = &no_hour[ 2.. ];
            no_minute = no_minute.trim_start_matches( ':' );
            if let Some( slice ) = no_minute.get( ..2 ) {
                match IsoSecond::from_str( slice ) {
                    Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                        string: String::from( "Invalid second." ),
                        identifier: String::from( "i18n_pattern/parse_second" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) ),
                    Ok( result ) => second = result
                }

                // try nanosecond
                let mut no_second = &no_minute[ 2.. ];
                no_second = no_second.trim_start_matches( '.' );
                match NanoSecond::from_str( no_second ) {
                    Err( _ ) => return Err( FormatterError::StringParse( ErrorMessage {
                        string: String::from( "Invalid nanosecond." ),
                        identifier: String::from( "i18n_pattern/parse_nanosecond" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) ),
                    Ok( result ) => nano = result
                }
            }
        }
    }
    Ok( Time::new( hour, minute, second, nano ) )
}

// Internal structures, enums, etc.

// Check node type.
fn check_node_type( tree: &Tree, index: usize, node_type: NodeType ) -> bool {
    let Ok( node_type_data ) = tree.node_type( index ) else {
        return false;
    };
    let Some( node_type2 ) = node_type_data.downcast_ref::<NodeType>() else {
        return false;
    };
    if node_type != *node_type2 {
        return false;
    }
    true
}

fn part_text(
    pattern: &mut Vec<PatternPart>,
    tree: &Tree,
    index: usize,
) -> Result<(), FormatterError> {
    let mut string = String::new();
    let Ok( text_data ) = tree.data_ref( index ) else {
        return Err( FormatterError::NodeData( ErrorMessage {
            string: String::from( "Could not retrieve data for Text node." ),
            identifier: String::from( "i18n_pattern/text_data" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };
    for token_data in text_data.iter() {
        let Some( token ) = token_data.downcast_ref::<Rc<Token>>() else {
            return Err( FormatterError::NodeData( ErrorMessage {
                string: String::from( "Could not retrieve token for Text node." ),
                identifier: String::from( "i18n_pattern/text_token" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        string.push_str( token.string.as_str() );
    }
    pattern.push( PatternPart::Text( string ) );
    Ok( () )
}

fn part_pattern(
    pattern: &mut Vec<PatternPart>,
    patterns: &HashMap<String, Vec<PatternPart>>,
    tree: &Tree,
    index: usize,
    selectors: &mut Vec<HashMap<String, String>>,
    option_selectors: &OptionSelectors,
    locale: &Rc<Locale>,
) -> Result<(), FormatterError> {
    let Ok( children ) = tree.children( index ) else {
        return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Could not retrieve children for Pattern." ),
            identifier: String::from( "i18n_pattern/pattern_children" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };
    let mut iterator = children.iter();

    // Identifier - first node
    let Some( placeholder ) = iterator.next() else {
        return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "No children nodes was not found." ),
            identifier: String::from( "i18n_pattern/no_children" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };
    if !check_node_type( tree, *placeholder, NodeType::Identifier ) {
        return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Identifier node was not found." ),
            identifier: String::from( "i18n_pattern/identifier_not_found" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    }
    let Ok( placeholder_data ) = tree.data_ref( *placeholder ) else {
        return Err( FormatterError::NodeData( ErrorMessage {
            string: String::from( "Could not retrieve data for placeholder node." ),
            identifier: String::from( "i18n_pattern/placeholder_data" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };
    let Some( placeholder_token ) = placeholder_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
        return Err( FormatterError::NodeData( ErrorMessage {
            string: String::from( "Failed to retrieve token for placeholder node." ),
            identifier: String::from( "i18n_pattern/placeholder_token" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };

    // Keyword - second node
    let keyword = match iterator.next() {
        None => {

            // placeholder with no parameters - defaults to string value
            pattern.push( PatternPart::PatternString( placeholder_token.string.to_string() ) );
            return Ok( () );
        },
        Some( keyword ) => *keyword
    };
    if !check_node_type( tree, keyword, NodeType::Identifier ) {
        return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Identifier node was not found." ),
            identifier: String::from( "i18n_pattern/identifier_not_found" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    }
    let Ok( keyword_data ) = tree.data_ref( keyword ) else {
        return Err( FormatterError::NodeData( ErrorMessage {
            string: String::from( "Could not retrieve data for keyword node." ),
            identifier: String::from( "i18n_pattern/keyword_data" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };
    let Some( keyword_token ) = keyword_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
        return Err( FormatterError::NodeData( ErrorMessage {
            string: String::from( "Failed to retrieve token for keyword node." ),
            identifier: String::from( "i18n_pattern/keyword_token" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };

    // Options and selectors for keywords.
    // TODO: add more options as they become non-experimental.
    if keyword_token.string.as_str() == "decimal" {

        // Currently the option can be repeated, though only final value is used.
        let strings = pattern_selectors( tree, index )?;
        let mut sign: Option<SignDisplay> = None;
        let mut group: Option<options::GroupingStrategy> = None;
        for ( key, value ) in strings.iter() {
            if key.as_str() == "sign" {
                sign = Some( sign_display( value.as_str() )? );
            } else if key.as_str() == "group" {
                group = Some( decimal_grouping_display( value.as_str() )? );
            } else {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Invalid option for decimal pattern." ),
                    identifier: String::from( "i18n_pattern/invalid_decimal_option" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
        }
        pattern.push(
            PatternPart::PatternDecimal{ placeholder: placeholder_token.string.to_string(), sign, group, }
        );
    } else if keyword_token.string.as_str() == "date_time" {

        // Currently the option can be repeated, though only final value is used.
        let strings = pattern_selectors( tree, index )?;
        let mut length_date: Option<DateLength> = None;
        let mut length_time: Option<TimeLength> = None;
        let mut calendar: Option<Locale> = None;
        for ( key, value ) in strings.iter() {
            if key.as_str() == "date" {
                length_date = Some( date_length( value.as_str() )? );
            } else if key.as_str() == "time" {
                length_time = Some( time_length( value.as_str() )? );
            } else if key.as_str() == "calendar" {
                if !option_selectors.calendars.contains( &value.as_str() ) {
                    return Err( FormatterError::InvalidNode( ErrorMessage {
                        string: String::from( "Invalid selector for ordinal pattern." ),
                        identifier: String::from( "i18n_pattern/invalid_ordinal_selector" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) );
                }
                let mut new_calendar = "-u-ca-".to_string();
                new_calendar.push_str( value.as_str() );
                let mut locale_string = locale.to_string();
                match locale_string.find( "-u-ca-" ) {
                    None => {
                        locale_string.push_str( new_calendar.as_str() );
                    },
                    Some( tag_position ) => {
                        let mut hyphens = locale_string.match_indices( "-" );
                        while let Some( pair ) = hyphens.next() {
                            if pair.0 == tag_position {
                                hyphens.next(); // There is an experimental advance_by( 2 ) to replace two next()
                                hyphens.next();
                                match hyphens.next() {
                                    None => {

                                        // The calendar tag is last tag
                                        let old_calendar =
                                            locale_string.get( tag_position.. ).unwrap();
                                        locale_string = locale_string.replace(
                                            old_calendar, new_calendar.as_str()
                                        );
                                    },
                                    Some( end ) => {
                                        new_calendar.push( '-' );
                                        let old_calendar =
                                            locale_string.get( tag_position..=end.0 ).unwrap();
                                        locale_string = locale_string.replace(
                                            old_calendar, new_calendar.as_str()
                                        );
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
                let Ok( calendar_locale ) = locale_string.parse() else {
                    return Err( FormatterError::StringParse( ErrorMessage {
                        string: String::from( "Failed to parse locale for calendar." ),
                        identifier: String::from( "i18n_pattern/parse_locale" ),
                        values: HashMap::<String, ErrorPlaceholderValue>::new(),
                    } ) );
                };
                calendar = Some( calendar_locale );
            } else {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Invalid option for date-time pattern." ),
                    identifier: String::from( "i18n_pattern/invalid_date_time_option" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
        }
        pattern.push(
            PatternPart::PatternDateTime{
                placeholder: placeholder_token.string.to_string(),
                length_date,
                length_time,
                calendar,
            }
        );
    } else if keyword_token.string.as_str() == "ordinal" {
        let strings = pattern_selectors( tree, index )?;
        let mut other = false;
        for ( key, named ) in strings.iter() {
            if !option_selectors.valid_plurals.contains( &key.as_str() ) {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Invalid selector for ordinal pattern." ),
                    identifier: String::from( "i18n_pattern/invalid_ordinal_selector" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
            if !patterns.contains_key( named ) {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Named string not found for selector." ),
                    identifier: String::from( "i18n_pattern/selector_named_string" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
            if key.as_str() == "other" {
                other = true;
            }
        }
        if !other {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Required 'other' selector was not found for keyword 'select'." ),
                identifier: String::from( "i18n_pattern/selector_other" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        }
        let len = selectors.len();
        selectors.push( strings );
        pattern.push( PatternPart::PatternComplex{
            placeholder: placeholder_token.string.to_string(),
            complex: ComplexType::Ordinal,
            selectors: len,
        } );
    } else if keyword_token.string.as_str() == "plural" {
        let strings = pattern_selectors( tree, index )?;
        let mut other = false;
        for ( key, named ) in strings.iter() {
            if !option_selectors.valid_plurals.contains( &key.as_str() ) {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Invalid selector for plural pattern." ),
                    identifier: String::from( "i18n_pattern/invalid_plural_selector" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
            if !patterns.contains_key( named ) {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Named string not found for selector." ),
                    identifier: String::from( "i18n_pattern/selector_named_string" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
            if key.as_str() == "other" {
                other = true;
            }
        }
        if !other {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Required 'other' selector was not found for keyword 'select'." ),
                identifier: String::from( "i18n_pattern/selector_other" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        }
        let len = selectors.len();
        selectors.push( strings );
        pattern.push( PatternPart::PatternComplex{
            placeholder: placeholder_token.string.to_string(),
            complex: ComplexType::Plural,
            selectors: len,
        } );
    } else if keyword_token.string.as_str() == "select" {
        let strings = pattern_selectors( tree, index )?;
        for ( _, named ) in strings.iter() {
            if !patterns.contains_key( named ) {
                return Err( FormatterError::InvalidNode( ErrorMessage {
                    string: String::from( "Named string not found for selector." ),
                    identifier: String::from( "i18n_pattern/selector_named_string" ),
                    values: HashMap::<String, ErrorPlaceholderValue>::new(),
                } ) );
            }
        }
        let len = selectors.len();
        selectors.push( strings );
        pattern.push( PatternPart::PatternComplex{
            placeholder: placeholder_token.string.to_string(),
            complex: ComplexType::Select,
            selectors: len,
        } );
    } else {
        return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Invalid placeholder keyword found." ),
            identifier: String::from( "i18n_pattern/keyword_not_found" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    }
    Ok( () )
}

fn pattern_selectors(
    tree: &Tree,
    index: usize,
) -> Result<HashMap<String, String>, FormatterError> {

    // Work around for inability to pass iterators, thus the iterator needs to be recreated.
    let Ok( children ) = tree.children( index ) else {
        return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Never reached." ),
            identifier: String::from( "i18n_pattern/never_reached" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) );
    };
    let mut iterator = children.iter().skip( 2 );

    let mut pairs = HashMap::<String, String>::new();
    while let Some( selector ) = iterator.next() {
        if !check_node_type( tree, *selector, NodeType::Selector ) {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Selector node was not found." ),
                identifier: String::from( "i18n_pattern/selector_not_found" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        }
        let Ok( first ) = tree.first( *selector ) else {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "First child of Selector node not found." ),
                identifier: String::from( "i18n_pattern/selector_first" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        if !check_node_type( tree, first, NodeType::Identifier ) {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Identifier node was not found." ),
                identifier: String::from( "i18n_pattern/identifier_not_found" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        }
        let Ok( first_data ) = tree.data_ref( first ) else {
            return Err( FormatterError::NodeData( ErrorMessage {
                string: String::from( "Could not retrieve data for selector first node." ),
                identifier: String::from( "i18n_pattern/selector_first_data" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        let Some( first_token ) = first_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
            return Err( FormatterError::NodeData( ErrorMessage {
                string: String::from( "Failed to retrieve token for selector first node." ),
                identifier: String::from( "i18n_pattern/selector_first_token" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        let Ok( last ) = tree.last( *selector ) else {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Last child of Selector node not found." ),
                identifier: String::from( "i18n_pattern/selector_last" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        if !check_node_type( tree, last, NodeType::Identifier ) {
            return Err( FormatterError::InvalidNode( ErrorMessage {
                string: String::from( "Identifier node was not found." ),
                identifier: String::from( "i18n_pattern/identifier_not_found" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        }
        let Ok( last_data ) = tree.data_ref( last ) else {
            return Err( FormatterError::NodeData( ErrorMessage {
                string: String::from( "Could not retrieve data for selector last node." ),
                identifier: String::from( "i18n_pattern/selector_last_data" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        let Some( last_token ) = last_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
            return Err( FormatterError::NodeData( ErrorMessage {
                string: String::from( "Failed to retrieve token for selector last node." ),
                identifier: String::from( "i18n_pattern/selector_last_data" ),
                values: HashMap::<String, ErrorPlaceholderValue>::new(),
            } ) );
        };
        pairs.insert( first_token.string.to_string(), last_token.string.to_string() );
    }
    Ok( pairs )
}

fn plural_category( category: PluralCategory ) -> &'static str {
    match category {
        PluralCategory::Zero => "zero",
        PluralCategory::One => "one",
        PluralCategory::Two => "two",
        PluralCategory::Few => "few",
        PluralCategory::Many => "many",
        PluralCategory::Other => "other",
    }
}

fn sign_display( sign: &str ) -> Result<SignDisplay, FormatterError> {
    match sign {
        "auto" => return Ok( SignDisplay::Auto ),
        "never" => return Ok( SignDisplay::Never ),
        "always" => return Ok( SignDisplay::Always ),
        "except_zero" => return Ok( SignDisplay::ExceptZero ),
        "negative" => return Ok( SignDisplay::Negative ),
        _ => return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Invalid decimal sign option." ),
            identifier: String::from( "i18n_pattern/option_decimal_sign" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) )
    }
}

fn decimal_grouping_display( group: &str ) -> Result<options::GroupingStrategy, FormatterError> {
    match group {
        "auto" => return Ok( options::GroupingStrategy::Auto ),
        "never" => return Ok( options::GroupingStrategy::Never ),
        "always" => return Ok( options::GroupingStrategy::Always ),
        "min2" => return Ok( options::GroupingStrategy::Min2 ),
        _ => return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Invalid decimal group option." ),
            identifier: String::from( "i18n_pattern/option_decimal_group" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) )
    }
}

fn date_length( len: &str ) -> Result<DateLength, FormatterError> {
    match len {
        "full" => return Ok( DateLength::Full ),
        "long" => return Ok( DateLength::Long ),
        "medium" => return Ok( DateLength::Medium ),
        "short" => return Ok( DateLength::Short ),
        _ => return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Invalid date length option." ),
            identifier: String::from( "i18n_pattern/option_date_length" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) )
    }
}

fn time_length( len: &str ) -> Result<TimeLength, FormatterError> {
    match len {
        "full" => return Ok( TimeLength::Full ),
        "long" => return Ok( TimeLength::Long ),
        "medium" => return Ok( TimeLength::Medium ),
        "short" => return Ok( TimeLength::Short ),
        _ => return Err( FormatterError::InvalidNode( ErrorMessage {
            string: String::from( "Invalid time length option." ),
            identifier: String::from( "i18n_pattern/option_time_length" ),
            values: HashMap::<String, ErrorPlaceholderValue>::new(),
        } ) )
    }
}

struct OptionSelectors<'a> {
    valid_plurals: Vec<&'a str>,
    calendars: Vec<&'a str>,
}

enum ComplexType {
    Plural,
    Ordinal,
    Select,
}

enum PatternPart {
    Text( String ),
    NumberSign( usize ),
    PatternString( String ),
    PatternDecimal{
        placeholder: String,
        sign: Option<SignDisplay>,
        group: Option<options::GroupingStrategy>,
    },
    PatternDateTime{
        placeholder: String,
        length_date: Option<DateLength>,
        length_time: Option<TimeLength>,
        calendar: Option<Locale>,
    },
    PatternComplex{
        placeholder: String,
        complex: ComplexType,
        selectors: usize,
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use icu_testdata::buffer;
    use i18n_lexer::Lexer;

    #[test]
    fn plain_text() {
        fn format_string() -> Result<(), FormatterError> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "A simple plain text string.", &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens ).expect( "Failed to parse tokens." );
            let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let language_tag = Rc::new( locale.to_string() );
            let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
            let values = HashMap::<String, PlaceholderValue>::new();
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!( result.as_str(), "A simple plain text string.", "Strings must be the same." );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_string() {
        fn format_string() -> Result<(), FormatterError> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "Expecting a string for placeholder: {string}", &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens ).expect( "Failed to parse tokens." );
            let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let language_tag = Rc::new( locale.to_string() );
            let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
            let mut values = HashMap::<String, PlaceholderValue>::new();
            values.insert(
                "string".to_string(),
                PlaceholderValue::String( "This is a string.".to_string() )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "Expecting a string for placeholder: This is a string.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_plural() {
        fn format_string() -> Result<(), FormatterError> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens ).expect( "Failed to parse tokens." );
            let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let language_tag = Rc::new( locale.to_string() );
            let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
            let mut values = HashMap::<String, PlaceholderValue>::new();
            values.insert(
                "dogs_number".to_string(),
                PlaceholderValue::Unsigned( 3 )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "There are 3 dogs in the park.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_decimal() {
        fn format_string() -> Result<(), FormatterError> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "There is {amount decimal} kg of rice in the container.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens ).expect( "Failed to parse tokens." );
            let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let language_tag = Rc::new( locale.to_string() );
            let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
            let mut values = HashMap::<String, PlaceholderValue>::new();
            values.insert(
                "amount".to_string(),
                PlaceholderValue::Float( 3.678 )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "There is 3,678 kg of rice in the container.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_decimal_with_option() {
        fn format_string() -> Result<(), FormatterError> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "There is {amount decimal sign#always} kg of rice in the container.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens ).expect( "Failed to parse tokens." );
            let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let language_tag = Rc::new( locale.to_string() );
            let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
            let mut values = HashMap::<String, PlaceholderValue>::new();
            values.insert(
                "amount".to_string(),
                PlaceholderValue::Float( 3.678 )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "There is +3,678 kg of rice in the container.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_dateime() {
        fn format_string() -> Result<(), FormatterError> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "At this point in time {time date_time} the moon winked out.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens ).expect( "Failed to parse tokens." );
            let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let language_tag = Rc::new( locale.to_string() );
            let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
            let mut values = HashMap::<String, PlaceholderValue>::new();
            values.insert(
                "time".to_string(),
                PlaceholderValue::DateTime( DateTime::<Iso>::new(
                    Date::try_new_iso_date( 248624, 10, 6 ).ok().unwrap(),
                    Time::try_new( 5, 47, 23, 254 ).ok().unwrap()
                ) )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "At this point in time 06 Oct 248624, 05:47:23 the moon winked out.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_dateime_string() {
        fn format_string() -> Result<(), FormatterError> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "At this point in time {time date_time} the moon winked out.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens ).expect( "Failed to parse tokens." );
            let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let language_tag = Rc::new( locale.to_string() );
            let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
            let mut values = HashMap::<String, PlaceholderValue>::new();
            values.insert(
                "time".to_string(),
                PlaceholderValue::String( "+248624-10-06T05:47:23.254".to_string() )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "At this point in time 06 Oct 248624, 05:47:23 the moon winked out.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }
}
