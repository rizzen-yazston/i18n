// This file is part of `i18n_pattern-rizzen-yazston` crate. For the terms of use, please see the file
// called `LICENSE-BSD-3-Clause` at the top level of the `i18n_pattern-rizzen-yazston` crate.

// Outstanding: Command, language tag wrapping, experimental ICU4X components and options.

//! The formatter takes the AST that was generated by the parser and constructs a string template for values to be
//! substituted into. The formatter also does the semantic analysis of the grammar. Once a string template has been
//! constructed, it can be used multiple times by simply supplying new placeholder values when executing the format()
//! method. Depending on the placeholder type of the pattern, a suitable selection of the available data types can be
//! used, these include the basic `String`, integers, unsigned integers and floats. In addition to these special ICU4X
//! types are supported such as `FixedDecimal`, `Date`, `Time` and `DateTime` structs.
//! 
//! See `pattern strings.asciidoc` in `docs` of `pattern` crate for the pattern formatting specification.
//!
//! # Examples
//!
//! ```
//! use icu_provider::prelude::*;
//! use std::rc::Rc;
//! use i18n_lexer::{Token, TokenType, Lexer};
//! use icu_testdata::buffer;
//! use i18n_pattern::{parse, NodeType, Formatter, PlaceholderValue, PlaceholderUnsigned};
//! use std::collections::HashMap;
//! 
//! fn format_string() -> Result<(), String> {
//!     let buffer_provider = Box::new( buffer() );
//!     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
//!     let tokens = lexer.tokenise(
//!         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
//!         &vec![ '{', '}', '`', '#' ]
//!     );
//!     let tree = parse( tokens )?;
//!     let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
//!     let mut formatter = Formatter::try_new( &locale, &tree )?;
//!     let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
//!     values.insert(
//!         "dogs_number".to_string(),
//!         Box::new( PlaceholderUnsigned { number: 3 } )
//!     );
//!     let result = formatter.format( &buffer_provider, &values )?;
//!     assert_eq!(
//!         result.as_str(),
//!         "There are 3 dogs in the park.",
//!         "Strings must be the same."
//!     );
//!     Ok( () )
//! }
//! match format_string() {
//!     Err( error ) => {
//!         println!( "Error: {}", error );
//!         assert!( false );
//!         return;
//!     },
//!     Ok( _ ) => {}
//! };
//! ```

use crate::*;
use i18n_lexer::Token;
use i18n_lstring::LString;
use tree::Tree;
use icu_provider::prelude::*;
use icu_locid::Locale;
use icu_plurals::{PluralCategory, PluralRules};
use icu_decimal::{FixedDecimalFormatter, options};
use fixed_decimal::{FixedDecimal, DoublePrecision, SignDisplay};
use icu_calendar::{
    types::{Time, IsoHour, IsoMinute, IsoSecond, NanoSecond},
    DateTime, Date, Iso
};
use icu_datetime::{
    options::length::{Bag, Date as DateLength, Time as TimeLength},
    DateTimeFormatter, DateFormatter, TimeFormatter
};
use std::collections::HashMap;
use std::rc::Rc;
use core::any::Any;
use std::str::FromStr;

pub struct Formatter {
    locale: Rc<Locale>,
    patterns: HashMap<String, Vec<Box<dyn Marker>>>,
    numbers: Vec<String>,
    selectors: Vec<HashMap<String, String>>,
}

impl Formatter {
    /// Creates a Formatter for a language string using parsing results.
    /// During the creation of the formatter for the supplied Tree, the semantic analyse is done.
    ///
    /// # Examples
    ///
    /// ```
    /// use icu_provider::prelude::*;
    /// use std::rc::Rc;
    /// use i18n_lexer::{Token, TokenType, Lexer};
    /// use icu_testdata::buffer;
    /// use i18n_pattern::{parse, NodeType, Formatter, PlaceholderValue, PlaceholderUnsigned};
    /// use std::collections::HashMap;
    /// 
    /// fn format_string() -> Result<(), String> {
    ///     let buffer_provider = Box::new( buffer() );
    ///     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
    ///     let tokens = lexer.tokenise(
    ///         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
    ///         &vec![ '{', '}', '`', '#' ]
    ///     );
    ///     let tree = parse( tokens )?;
    ///     let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
    ///     let mut formatter = Formatter::try_new( &locale, &tree )?;
    ///     let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
    ///     values.insert(
    ///         "dogs_number".to_string(),
    ///         Box::new( PlaceholderUnsigned { number: 3 } )
    ///     );
    ///     let result = formatter.format( &buffer_provider, &values )?;
    ///     assert_eq!(
    ///         result.as_str(),
    ///         "There are 3 dogs in the park.",
    ///         "Strings must be the same."
    ///     );
    ///     Ok( () )
    /// }
    /// match format_string() {
    ///     Err( error ) => {
    ///         println!( "Error: {}", error );
    ///         assert!( false );
    ///         return;
    ///     },
    ///     Ok( _ ) => {}
    /// };
    /// ```
    pub fn try_new(
        locale: &Rc<Locale>,
        tree: &Tree,
    ) -> Result<Self, String> {
        let mut patterns = HashMap::<String, Vec<Box<dyn Marker>>>::new();
        patterns.insert( "_".to_string(), Vec::<Box<dyn Marker>>::new() ); // Insert empty main pattern.
        let mut numbers = Vec::<String>::new();
        let mut selectors = Vec::<HashMap<String, String>>::new();
        if tree.len() == 0 {
            return Ok( Formatter {
                locale: Rc::clone( &locale ),
                patterns,
                numbers,
                selectors,
            } );
        }
        let option_selectors = OptionSelectors {
            valid_plurals: vec![ "zero", "one", "two", "few", "many",  "other" ],
            calendars: vec![ "gregorian", "buddhist", "japanese", "ethiopian", "indian", "coptic" , "iso" ],
        };
        if !check_node_type( tree, 0, NodeType::Root ) {
            return Err( "Tree root is not a Root node.".to_string() );
        }

        // Process substrings first if present.
        if let Ok( last ) = tree.last( 0 ) {
            if check_node_type( tree, last, NodeType::NamedGroup ) {
                let Ok( named_strings ) = tree.children( last ) else {
                    return Err( "Could not retrieve children for NamedGroup.".to_string() );
                };
                for named in named_strings.iter() {
                    let mut pattern = Vec::<Box<dyn Marker>>::new();
                    if !check_node_type( tree, *named, NodeType::NamedString ) {
                        return Err( "NamedString node was not found.".to_string() );
                    }
    
                    // Get NamedString identifier and check it is not already present.
                    let Ok( first ) = tree.first( *named ) else {
                        return Err( "First child of NamedString node not found.".to_string() );
                    };
                    if !check_node_type( tree, first, NodeType::Identifier ) {
                        return Err( "Identifier node was not found.".to_string() );
                    }
                    let Ok(identifier_data ) = tree.data_ref( first ) else {
                        return Err( "Could not retrieve data for Identifier node.".to_string() );
                    };
                    let Some( identifier_token ) = identifier_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
                        return Err( "Failed to retrieve token for Identifier node.".to_string() ) ;
                    };
                    if patterns.contains_key( identifier_token.string.as_str() ) {
                        return Err( "NamedString identifiers must be unique and not `_`.".to_string() );
                    }
    
                    // Got NamedString identifier
                    let Ok( last ) = tree.last( *named ) else {
                        return Err( "Last child of NamedString node not found.".to_string() );
                    };
                    if !check_node_type( tree, last, NodeType::String ) {
                        return Err("String node was not found.".to_string());
                    }
                    let Ok( children ) = tree.children( last ) else {
                        return Err( "Could not retrieve children for String.".to_string() );
                    };
                    for child in children.iter() {
                        if check_node_type( tree, *child, NodeType::Text ) {
                            part_text( &mut pattern, tree, *child )?;
                        } else if check_node_type( tree, *child, NodeType::NumberSign ) {
                            let len = numbers.len();
                            numbers.push( String::new() );
                            pattern.push( Box::new(
                                NumberSign { index: len }
                            ) );
                        } else if check_node_type( tree, *child, NodeType::Pattern ) {
                            part_pattern(
                                &mut pattern, 
                                &patterns, 
                                tree,
                                *child,
                                &mut selectors,
                                &option_selectors,
                                locale,
                            )?;
                        } else if check_node_type( tree, *child, NodeType::Command ) {
                            // TODO: create a method as both NamedString and main String has Command.
                        } else {
                            return Err( "Invalid node found in String.".to_string() );
                        }
                    }
                    patterns.insert( identifier_token.string.as_str().to_string(), pattern );
                }
            }
        };

        // Now process main string.
        let mut pattern = Vec::<Box<dyn Marker>>::new();
        let Ok( first ) = tree.first( 0 ) else {
            return Err( "First child of Root node not found.".to_string() );
        };
        if !check_node_type( tree, first, NodeType::String ) {
            return Err( "String node was not found.".to_string() );
        }
        let Ok( children ) = tree.children( first ) else {
            return Err( "Could not retrieve children for String.".to_string() );
        };
        for child in children.iter() {
            if check_node_type( tree, *child, NodeType::Text ) {
                part_text( &mut pattern, tree, *child )?;
            } else if check_node_type( tree, *child, NodeType::Pattern ) {
                part_pattern(
                    &mut pattern, 
                    &patterns, 
                    tree,
                    *child,
                    &mut selectors,
                    &option_selectors,
                    locale,
                )?;
            } else if check_node_type( tree, *child, NodeType::Command ) {
                // TODO: create a method as both NamedString and main String has Command.
            } else {
                return Err( "Invalid node found in String.".to_string() );
            }
        }
        patterns.insert( "_".to_string(), pattern );
        Ok( Formatter {
            locale: Rc::clone( &locale ),
            patterns,
            numbers,
            selectors,
        } )
    }

    /// Format the language string with supplied values.
    /// Possible have options to handle nested language strings to wrap inner language string in language tags.
    ///
    /// # Examples
    ///
    /// ```
    /// use icu_provider::prelude::*;
    /// use std::rc::Rc;
    /// use i18n_lexer::{Token, TokenType, Lexer};
    /// use icu_testdata::buffer;
    /// use i18n_pattern::{parse, NodeType, Formatter, PlaceholderValue, PlaceholderUnsigned};
    /// use std::collections::HashMap;
    /// 
    /// fn format_string() -> Result<(), String> {
    ///     let buffer_provider = Box::new( buffer() );
    ///     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
    ///     let tokens = lexer.tokenise(
    ///         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
    ///         &vec![ '{', '}', '`', '#' ]
    ///     );
    ///     let tree = parse( tokens )?;
    ///     let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
    ///     let mut formatter = Formatter::try_new( &locale, &tree )?;
    ///     let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
    ///     values.insert(
    ///         "dogs_number".to_string(),
    ///         Box::new( PlaceholderUnsigned { number: 3 } )
    ///     );
    ///     let result = formatter.format( &buffer_provider, &values )?;
    ///     assert_eq!(
    ///         result.as_str(),
    ///         "There are 3 dogs in the park.",
    ///         "Strings must be the same."
    ///     );
    ///     Ok( () )
    /// }
    /// match format_string() {
    ///     Err( error ) => {
    ///         println!( "Error: {}", error );
    ///         assert!( false );
    ///         return;
    ///     },
    ///     Ok( _ ) => {}
    /// };
    /// ```
    pub fn format(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, Box<dyn PlaceholderValue>>
    ) -> Result<LString, String> {
        if self.patterns.get( "_" ).unwrap().len() == 0 {
            return Ok( LString::new( String::new(), Rc::clone( &self.locale ) ) );
        }
        let pattern_string = self.format_pattern(
            buffer_provider,
            values,
            &"_".to_string(),
        )?;
        Ok( LString::new( pattern_string, Rc::clone( &self.locale ) ) )
    }

    /// Returns the locale used in creating the formatter.
    pub fn locale( &self ) -> &Rc<Locale> {
        &self.locale
    }

    // Internal methods

    fn part_ref( &self, string: &String, index: usize ) -> Option<&Box<dyn Marker>> {
        if let Some( pattern ) = self.patterns.get( string ) {
            if let Some( part ) = pattern.get( index ) {
                return Some( part );
            }
        }
        None
    }

    fn format_pattern(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, Box<dyn PlaceholderValue>>,
        named: &String
    ) -> Result<String, String> {
        let mut string = String::new();
        let mut _len = 0usize;
        {
            let Some( pattern ) = self.patterns.get( named ) else {
                return Err( "Failed to retrieve named string pattern.".to_string() );
            };
            _len = pattern.len();
        }
        let mut i = 0usize;
        while i < _len {
            let Some( part ) = self.part_ref( named, i ) else {
                return Err( "Could not retrieve part of pattern.".to_string() );
            };
            match part.get_type() {
                "Text" => {
                    let Some( actual_part ) = part.as_any().downcast_ref::<Text>() else {
                        return Err( "Could not retrieve data for Text.".to_string() );
                    };
                    string.push_str( actual_part.string.as_str() );
                },
                "PatternString" => {
                    let Some( actual_part ) = part.as_any().downcast_ref::<PatternString>() else {
                        return Err( "Could not retrieve data for PatternString.".to_string() );
                    };
                    let Some( value ) = values.get( &actual_part.placeholder ) else {
                        return Err( "Placeholder value is not found for PatternString.".to_string() );
                    };
                    match value.get_type() {
                        "PlaceholderString" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderString>() else {
                                return Err( "Could not retrieve data for PlaceholderString.".to_string() );
                            };
                            string.push_str( actual_value.string.as_str() );
                        },
                        "PlaceholderLString" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderLString>() else {
                                return Err( "Could not retrieve data for PlaceholderLString.".to_string() );
                            };
                            // Currently no option to wrap string in language tags: `[en]substring[/en]`
                            // probably best place for wrap option flag is to put in the struct itself
                            string.push_str( actual_value.string.as_str() );
                        },
                        _ => return Err( "Invalid value type provided for PatternString.".to_string() )
                    }
                },
                "PatternDecimal" => {
                    let Some( actual_part ) = part.as_any().downcast_ref::<PatternDecimal>() else {
                        return Err( "Could not retrieve data for PatternDecimal.".to_string() );
                    };
                    let Some( value ) = values.get( &actual_part.placeholder ) else {
                        return Err( "Placeholder value is not found for PatternDecimal.".to_string() );
                    };
                    let data_locale = DataLocale::from( Rc::as_ref( &self.locale ) );
                    let mut options: options::FixedDecimalFormatterOptions = Default::default();
                    if actual_part.group.is_some() {
                        options.grouping_strategy = actual_part.group.unwrap();
                    }
                    let Ok( fdf ) = FixedDecimalFormatter::try_new_with_buffer_provider(
                        buffer_provider,
                        &data_locale,
                        options,
                    ) else {
                        return Err( "Failed to load decimal formatting information for locale.".to_string() );
                    };
                    match value.get_type() {
                        "PlaceholderFixedDecimal" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderFixedDecimal>() else {
                                return Err( "Could not retrieve data for PlaceholderFixedDecimal.".to_string() );
                            };
                            let fixed_decimal = &mut actual_value.number.clone();
                            if actual_part.sign.is_some() {
                                fixed_decimal.apply_sign_display( actual_part.sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        "PlaceholderUnsigned" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderUnsigned>() else {
                                return Err( "Could not retrieve data for PlaceholderUnsigned.".to_string() );
                            };
                            let mut fixed_decimal = FixedDecimal::from( actual_value.number );
                            if actual_part.sign.is_some() {
                                fixed_decimal.apply_sign_display( actual_part.sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        "PlaceholderInteger" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderInteger>() else {
                                return Err( "Could not retrieve data for PlaceholderInteger.".to_string() );
                            };
                            let mut fixed_decimal = FixedDecimal::from( actual_value.number );
                            if actual_part.sign.is_some() {
                                fixed_decimal.apply_sign_display( actual_part.sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        "PlaceholderFloat" => {
                            // Precision is always Floating, for other precisions options use PlaceholderFixedDecimal
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderFloat>() else {
                                return Err( "Could not retrieve data for PlaceholderFloat.".to_string() );
                            };
                            let Ok( mut fixed_decimal ) = FixedDecimal::try_from_f64(
                                actual_value.number, DoublePrecision::Floating
                            ) else {
                                return Err( "Failed to created FixedDecimal for PlaceholderFloat.".to_string() );
                            };
                            if actual_part.sign.is_some() {
                                fixed_decimal.apply_sign_display( actual_part.sign.unwrap() );
                            }
                            let number_string = fdf.format( &fixed_decimal ).to_string();
                            string.push_str( number_string.as_str() );
                        },
                        _ => return Err( "Invalid value type provided for PatternDecimal.".to_string() )
                    }
                },
                "PatternDateTime" => {
                    // TODO: add more options as they become non-experimental.
                    // TODO: implement hour for Time/DateTime when no longer experimental
                    let Some( actual_part ) = part.as_any().downcast_ref::<PatternDateTime>() else {
                        return Err( "Could not retrieve data for PatternDateTime.".to_string() );
                    };
                    let Some( value ) = values.get( &actual_part.placeholder ) else {
                        return Err( "Placeholder value is not found for PatternDateTime.".to_string() );
                    };
                    let length_date = match actual_part.length_date {
                        None => DateLength::Medium,
                        Some( result ) => result
                    };
                    let length_time = match actual_part.length_time {
                        None => TimeLength::Medium,
                        Some( result ) => result
                    };
                    let options = Bag::from_date_time_style(
                        length_date,
                        length_time,
                    );
                    let data_locale = match &actual_part.calendar {
                        None => DataLocale::from( Rc::as_ref( &self.locale ) ),
                        Some( locale ) => DataLocale::from( locale )
                    };
                    match value.get_type() {
                        "PlaceholderDateTime" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderDateTime>() else {
                                return Err( "Could not retrieve data for PlaceholderDateTime.".to_string() );
                            };
                            let Ok( dtf ) = DateTimeFormatter::try_new_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                                options.into(),
                            ) else {
                                return Err( "Failed to load date-time formatting information for locale.".to_string() );
                            };
                            let Ok( date_string ) = dtf.format_to_string( &actual_value.date_time ) else {
                                return Err( "Could not format date-time for locale.".to_string() );
                            };
                            string.push_str( date_string.as_str() );
                        },
                        "PlaceholderDate" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderDate>() else {
                                return Err( "Could not retrieve data for PlaceholderDate.".to_string() );
                            };
                            let Ok( df ) = DateFormatter::try_new_with_length_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                                length_date,
                            ) else {
                                return Err( "Failed to load date formatting information for locale.".to_string() );
                            };
                            let Ok( date_string ) = df.format_to_string( &actual_value.date ) else {
                                return Err( "Could not format date for locale.".to_string() );
                            };
                            string.push_str( date_string.as_str() );
                        },
                        "PlaceholderTime" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderTime>() else {
                                return Err( "Could not retrieve data for PlaceholderTime.".to_string() );
                            };
                            let Ok( tf ) = TimeFormatter::try_new_with_length_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                                length_time,
                            ) else {
                                return Err( "Failed to load date formatting information for locale.".to_string() );
                            };
                            let date_string = tf.format_to_string( &actual_value.time );
                            string.push_str( date_string.as_str() );
                        },
                        "PlaceholderString" => {
                            let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderString>() else {
                                return Err( "Could not retrieve data for PlaceholderString.".to_string() );
                            };
                            let date_time_strings: Vec<&str> = actual_value.string.split( 'T' ).collect();
                            if date_time_strings.len() == 2 {
                                if date_time_strings[ 0 ] == "" {
                                    // time only
                                    let time: Time = decompose_iso_time( date_time_strings[ 1 ] )?;
                                    let Ok( tf ) = TimeFormatter::try_new_with_length_with_buffer_provider(
                                        buffer_provider,
                                        &data_locale,
                                        length_time,
                                    ) else {
                                        return Err(
                                            "Failed to load date formatting information for locale.".to_string()
                                        );
                                    };
                                    let date_string = tf.format_to_string( &time );
                                    string.push_str( date_string.as_str() );
                                } else {
                                    // date and time
                                    let date: Date<Iso> = decompose_iso_date( date_time_strings[ 0 ] )?;
                                    let time: Time = decompose_iso_time( date_time_strings[ 1 ] )?;
                                    let date_time = DateTime::<Iso>::new( date, time );
                                    let Ok( dtf ) = DateTimeFormatter::try_new_with_buffer_provider(
                                        buffer_provider,
                                        &data_locale,
                                        options.into(),
                                    ) else {
                                        return Err(
                                            "Failed to load date-time formatting information for locale.".to_string()
                                        );
                                    };
                                    let Ok( date_string ) = dtf.format_to_string( &date_time.to_any() ) else {
                                        return Err( "Could not format date-time for locale.".to_string() );
                                    };
                                    string.push_str( date_string.as_str() );
                                }
                            } else {
                                // date only
                                let date: Date<Iso> = decompose_iso_date( date_time_strings[ 0 ] )?;
                                let Ok( df ) = DateFormatter::try_new_with_length_with_buffer_provider(
                                    buffer_provider,
                                    &data_locale,
                                    length_date,
                                ) else {
                                    return Err( "Failed to load date formatting information for locale.".to_string() );
                                };
                                let Ok( date_string ) = df.format_to_string( &date.to_any() ) else {
                                    return Err( "Could not format date for locale.".to_string() );
                                };
                                string.push_str( date_string.as_str() );
                            }
                        },
                        _ => return Err( "Invalid value type provided for PatternDecimal.".to_string() )
                    }
                },
                "PatternComplex" => {
                    let Some( actual_part ) = part.as_any().downcast_ref::<PatternComplex>() else {
                        return Err( "Could not retrieve data for PatternComplex.".to_string() );
                    };
                    let Some( value ) = values.get( &actual_part.placeholder ) else {
                        return Err( "Placeholder value is not found for PatternComplex.".to_string() );
                    };
                    let selectors_index = actual_part.selectors;
                    let data_locale = DataLocale::from( Rc::as_ref( &self.locale ) );
                    match actual_part.complex {
                        ComplexType::Plural => {
                            let Ok( plurals ) = PluralRules::try_new_cardinal_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                            ) else {
                                return Err( "Failed to retrieve plural rules for locale.".to_string() );
                            };
                            match value.get_type() {
                                "PlaceholderFixedDecimal" => {
                                    let Some( actual_value ) =
                                        value.as_any().downcast_ref::<PlaceholderFixedDecimal>() else {
                                        return Err(
                                            "Could not retrieve data for PlaceholderFixedDecimal.".to_string()
                                        );
                                    };
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &actual_value.number,
                                        plurals,
                                        &data_locale,
                                        selectors_index,
                                    )?;
                                },
                                "PlaceholderUnsigned" => {
                                    let Some( actual_value ) =
                                        value.as_any().downcast_ref::<PlaceholderUnsigned>() else {
                                        return Err( "Could not retrieve data for PlaceholderUnsigned.".to_string() );
                                    };
                                    let fixed_decimal = FixedDecimal::from( actual_value.number );
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        selectors_index,
                                    )?;
                                },
                                "PlaceholderInteger" => {
                                    let Some( actual_value ) =
                                        value.as_any().downcast_ref::<PlaceholderInteger>() else {
                                        return Err( "Could not retrieve data for PlaceholderInteger.".to_string() );
                                    };
                                    let fixed_decimal = FixedDecimal::from( actual_value.number );
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        selectors_index,
                                    )?;
                                },
                                "PlaceholderFloat" => {
                                    // Precision is always Floating, for other precisions options use
                                    // PlaceholderFixedDecimal with FixedDecimal::try_from_f64().
                                    let Some( actual_value ) = value.as_any().downcast_ref::<PlaceholderFloat>() else {
                                        return Err( "Could not retrieve data for PlaceholderFloat.".to_string() );
                                    };
                                    let Ok( fixed_decimal ) = FixedDecimal::try_from_f64(
                                        actual_value.number, DoublePrecision::Floating
                                    ) else {
                                        return Err(
                                            "Failed to created FixedDecimal for PlaceholderFloat.".to_string()
                                        );
                                    };
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        selectors_index,
                                    )?;
                                },
                                _ => return Err( "Invalid value type provided for PatternOrdinal.".to_string() )
                            }
                        },
                        ComplexType::Ordinal => {
                            // Only positive integers and zero are allowed.
                            let Ok( plurals ) = PluralRules::try_new_ordinal_with_buffer_provider(
                                buffer_provider,
                                &data_locale,
                            ) else {
                                return Err( "Failed to retrieve plural rules for locale.".to_string() );
                            };
                            match value.get_type() {
                                "PlaceholderUnsigned" => {
                                    let Some( actual_value ) =
                                        value.as_any().downcast_ref::<PlaceholderUnsigned>() else {
                                        return Err( "Could not retrieve data for PlaceholderUnsigned.".to_string() );
                                    };
                                    let fixed_decimal = FixedDecimal::from( actual_value.number );
                                    self.find_number_sign(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &fixed_decimal,
                                        plurals,
                                        &data_locale,
                                        selectors_index,
                                    )?;
                                },
                                _ => return Err( "Invalid value type provided for PatternOrdinal.".to_string() )
                            }
                        },
                        ComplexType::Select => {
                            match value.get_type() {
                                "PlaceholderString" => {
                                    let Some( actual_value ) =
                                        value.as_any().downcast_ref::<PlaceholderString>() else {
                                        return Err( "Could not retrieve data for PlaceholderString.".to_string() );
                                    };
                                    self.select(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &actual_value.string,
                                        selectors_index,
                                    )?;
                                },
                                "PlaceholderLString" => {
                                    // Locale is not used, and LSring is just treated as String for the selector
                                    let Some( actual_value ) =
                                        value.as_any().downcast_ref::<PlaceholderLString>() else {
                                        return Err( "Could not retrieve data for PlaceholderLString.".to_string() );
                                    };
                                    self.select(
                                        buffer_provider,
                                        values,
                                        &mut string,
                                        &actual_value.string.as_str().to_string(),
                                        selectors_index,
                                    )?;
                                },
                                _ => return Err( "Invalid value type provided for PatternOrdinal.".to_string() )
                            }
                        },
                    }
                },
                "NumberSign" => {
                    let Some( actual_part ) = part.as_any().downcast_ref::<NumberSign>() else {
                        return Err( "Could not retrieve data for NumberSign.".to_string() );
                    };
                    let Some( number_string ) = self.numbers.get( actual_part.index ) else {
                        return Err( "Unable to retrieve reference for NumberSign index.".to_string() );
                    };
                    string.push_str( number_string.as_str() );
                },
                _ => { // Should never reach.
                    return Err( "Invalid part type found.".to_string() );
                }
            }
            i += 1;
        }
        Ok( string )
    }

    fn find_number_sign(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, Box<dyn PlaceholderValue>>,
        string: &mut String,
        fixed_decimal: &FixedDecimal,
        plurals: PluralRules,
        data_locale: &DataLocale,
        selectors_index: usize,
    ) -> Result<(), String> {

        // Format number using graphemes of the locale.
        let Ok( fdf ) = FixedDecimalFormatter::try_new_with_buffer_provider(
            buffer_provider,
            data_locale,
            Default::default(),
        ) else {
            return Err( "Failed to load decimal formatting information for locale.".to_string() );
        };
        let number_string = fdf.format( fixed_decimal ).to_string();
        let category = plural_category( plurals.category_for( fixed_decimal ) ).to_string();

        // Get the named string, and locate number signs to update the string.
        let Some( selectors ) = self.selectors.get( selectors_index ) else {
            return Err( "Index not found in selectors.".to_string() );
        };
        let Some( named ) = selectors.get( &category ) else {
            return Err( "Failed to retrieve named string from selector.".to_string() );
        };
        let mut _len = 0usize;
        {
            let Some( pattern ) = self.patterns.get( named ) else {
                return Err( "Failed to retrieve named string pattern.".to_string() );
            };
            _len = pattern.len();
        }
        let mut i = 0usize;
        while i < _len {
            let Some( part ) = self.part_ref( named, i ) else {
                return Err( "Could not retrieve part of pattern.".to_string() );
            };
            if part.get_type() == "NumberSign" {
                let Some( actual_part ) = part.as_any().downcast_ref::<NumberSign>() else {
                    return Err( "Could not retrieve data for NumberSign.".to_string() );
                };
                let index = actual_part.index; // Gets around the immutable borrow issue.
                let Some( number_string_mut ) = self.numbers.get_mut( index ) else {
                    return Err( "Unable to retrieve reference for NumberSign string.".to_string() );
                };
                *number_string_mut = number_string.to_string();
            }
            i += 1;
        }
        let part_string = self.format_pattern(
            buffer_provider,
            values,
            &named.to_string()
        )?;
        string.push_str( part_string.as_str() );
        Ok( () )
    }

    fn select(
        &mut self,
        buffer_provider: &Box<impl BufferProvider + ?Sized>,
        values: &HashMap<String, Box<dyn PlaceholderValue>>,
        string: &mut String,
        string_value: &String,
        selectors_index: usize,
    ) -> Result<(), String> {
    
        // Get the named string, and locate number signs to update the string.
        let Some( selectors ) = self.selectors.get( selectors_index ) else {
            return Err( "Index not found in selectors.".to_string() );
        };
        let Some( named ) = selectors.get( string_value ) else {
            return Err( "Failed to retrieve named string from selector.".to_string() );
        };
        let part_string = self.format_pattern(
            buffer_provider,
            values,
            &named.to_string(),
        )?;
        string.push_str( part_string.as_str() );
        Ok( () )
    }
}

// Internal structures, enums, etc.

// Check node type.
fn check_node_type( tree: &Tree, index: usize, node_type: NodeType ) -> bool {
    let Ok( node_type_data ) = tree.node_type( index ) else {
        return false;
    };
    let Some( node_type2 ) = node_type_data.downcast_ref::<NodeType>() else {
        return false;
    };
    if node_type != *node_type2 {
        return false;
    }
    true
}

fn part_text(
    pattern: &mut Vec<Box<dyn Marker>>,
    tree: &Tree,
    index: usize,
) -> Result<(), String> {
    let mut string = String::new();
    let Ok( text_data ) = tree.data_ref( index ) else {
        return Err( "Could not retrieve data for Text node.".to_string() );
    };
    for token_data in text_data.iter() {
        let Some( token ) = token_data.downcast_ref::<Rc<Token>>() else {
            return Err( "Could not retrieve token for Text node.".to_string() );
        };
        string.push_str( token.string.as_str() );
    }
    pattern.push( Box::new( Text { string } ) );
    Ok( () )
}

fn part_pattern(
    pattern: &mut Vec<Box<dyn Marker>>,
    patterns: &HashMap<String, Vec<Box<dyn Marker>>>,
    tree: &Tree,
    index: usize,
    selectors: &mut Vec<HashMap<String, String>>,
    option_selectors: &OptionSelectors,
    locale: &Rc<Locale>,
) -> Result<(), String> {
    let Ok( children ) = tree.children( index ) else {
        return Err( "Could not retrieve children for Pattern.".to_string() );
    };
    let mut iterator = children.iter();

    // Identifier - first node
    let Some( placeholder ) = iterator.next() else {
        return Err( "No children nodes was not found.".to_string() );
    };
    if !check_node_type( tree, *placeholder, NodeType::Identifier ) {
        return Err( "Identifier node was not found.".to_string() );
    }
    let Ok( placeholder_data ) = tree.data_ref( *placeholder ) else {
        return Err( "Could not retrieve data for placeholder node.".to_string() );
    };
    let Some( placeholder_token ) = placeholder_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
        return Err( "Failed to retrieve token for placeholder node.".to_string() );
    };

    // Keyword - second node
    let keyword = match iterator.next() {
        None => {
            // placeholder with no parameters - string value
            pattern.push(
                Box::new(
                    PatternString {
                        placeholder: placeholder_token.string.to_string(),
                    }
                )
            );
            return Ok( () );
        },
        Some( keyword ) => *keyword
    };
    if !check_node_type( tree, keyword, NodeType::Identifier ) {
        return Err( "Identifier node was not found.".to_string() );
    }
    let Ok( keyword_data ) = tree.data_ref( keyword ) else {
        return Err( "Could not retrieve data for keyword node.".to_string() );
    };
    let Some( keyword_token ) = keyword_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
        return Err( "Failed to retrieve token for keyword node.".to_string() );
    };

    // Options and selectors for keywords.
    if keyword_token.string.as_str() == "decimal" {
        let strings = pattern_selectors( tree, index )?;
        let mut sign: Option<SignDisplay> = None;
        let mut group: Option<options::GroupingStrategy> = None;
        for ( key, value ) in strings.iter() {
            // TODO: add more options as they become non-experimental.
            if key.as_str() == "sign" {
                sign = match sign_display( value.as_str() ) {
                    Err( error ) => return Err( error ),
                    Ok( result ) => Some( result )
                };
            } else if key.as_str() == "group" {
                group = match decimal_grouping_display( value.as_str() ) {
                    Err( error ) => return Err( error ),
                    Ok( result ) => Some( result )
                };
            } else {
                return Err( "Invalid option for decimal pattern.".to_string() );
            }
        }
        pattern.push(
            Box::new(
                PatternDecimal {
                    placeholder: placeholder_token.string.to_string(),
                    sign,
                    group,
                }
            )
        );
    } else if keyword_token.string.as_str() == "date_time" {
        let strings = pattern_selectors( tree, index )?;
        let mut length_date: Option<DateLength> = None;
        let mut length_time: Option<TimeLength> = None;
        let mut calendar: Option<Locale> = None;
        for ( key, value ) in strings.iter() {
            // TODO: add more options as they become non-experimental.
            if key.as_str() == "date" {
                length_date = match date_length( value.as_str() ) {
                    Err( error ) => return Err( error ),
                    Ok( result ) => Some( result )
                };
            } else if key.as_str() == "time" {
                length_time = match time_length( value.as_str() ) {
                    Err( error ) => return Err( error ),
                    Ok( result ) => Some( result )
                };
            } else if key.as_str() == "calendar" {
                if !option_selectors.calendars.contains( &value.as_str() ) {
                    return Err( "Invalid selector for ordinal pattern.".to_string() );
                }
                let mut new_calendar = "-u-ca-".to_string();
                new_calendar.push_str( value.as_str() );
                let mut locale_string = locale.to_string();
                match locale_string.find( "-u-ca-" ) {
                    None => {
                        locale_string.push_str( new_calendar.as_str() );
                    },
                    Some( tag_position ) => {
                        let mut hyphens = locale_string.match_indices( "-" );
                        while let Some( pair ) = hyphens.next() {
                            if pair.0 == tag_position {
                                hyphens.next(); //there is an experimental advance_by( 2 ) to replace two next()
                                hyphens.next();
                                match hyphens.next() {
                                    None => {
                                        //the calendar tag is last tag
                                        let old_calendar =
                                            locale_string.get( tag_position.. ).unwrap();
                                        locale_string = locale_string.replace(
                                            old_calendar, new_calendar.as_str()
                                        );
                                    },
                                    Some( end ) => {
                                        new_calendar.push( '-' );
                                        let old_calendar =
                                            locale_string.get( tag_position..=end.0 ).unwrap();
                                        locale_string = locale_string.replace(
                                            old_calendar, new_calendar.as_str()
                                        );
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
                let Ok( calendar_locale ) = locale_string.parse() else {
                    return Err( "Failed to parse locale for calendar.".to_string() );
                };
                calendar = Some( calendar_locale );
            } else {
                return Err( "Invalid option for date-time pattern.".to_string() );
            }
        }
        pattern.push(
            Box::new(
                PatternDateTime {
                    placeholder: placeholder_token.string.to_string(),
                    length_date,
                    length_time,
                    calendar,
                }
            )
        );
    } else if keyword_token.string.as_str() == "ordinal" {
        let strings = pattern_selectors( tree, index )?;
        let mut other = false;
        for ( key, named ) in strings.iter() {
            if !option_selectors.valid_plurals.contains( &key.as_str() ) {
                return Err( "Invalid selector for ordinal pattern.".to_string() );
            }
            if !patterns.contains_key( named ) {
                return Err( "Named string not found for selector.".to_string() );
            }
            if key.as_str() == "other" {
                other = true;
            }
        }
        if !other {
            return Err( "Required 'other' selector was not found for keyword 'select'.".to_string() );
        }
        let len = selectors.len();
        selectors.push( strings );
        pattern.push( Box::new( PatternComplex {
            placeholder: placeholder_token.string.to_string(),
            complex: ComplexType::Ordinal,
            selectors: len,
        } ) );
    } else if keyword_token.string.as_str() == "plural" {
        let strings = pattern_selectors( tree, index )?;
        let mut other = false;
        for ( key, named ) in strings.iter() {
            if !option_selectors.valid_plurals.contains( &key.as_str() ) {
                return Err( "Invalid selector for plural pattern.".to_string() );
            }
            if !patterns.contains_key( named ) {
                return Err( "Named string not found for selector.".to_string() );
            }
            if key.as_str() == "other" {
                other = true;
            }
        }
        if !other {
            return Err( "Required 'other' selector was not found for keyword 'select'.".to_string() );
        }
        let len = selectors.len();
        selectors.push( strings );
        pattern.push( Box::new( PatternComplex {
            placeholder: placeholder_token.string.to_string(),
            complex: ComplexType::Plural,
            selectors: len,
        } ) );
    } else if keyword_token.string.as_str() == "select" {
        let strings = pattern_selectors( tree, index )?;
        for ( _, named ) in strings.iter() {
            if !patterns.contains_key( named ) {
                return Err( "Named string not found for selector.".to_string() );
            }
        }
        let len = selectors.len();
        selectors.push( strings );
        pattern.push( Box::new( PatternComplex {
            placeholder: placeholder_token.string.to_string(),
            complex: ComplexType::Select,
            selectors: len,
        } ) );
    } else {
        return Err( "Invalid placeholder keyword found.".to_string() );
    }
    Ok( () )
}

fn pattern_selectors(
    tree: &Tree,
    index: usize,
) -> Result<HashMap<String, String>, String> {

    // Work around for inability to pass iterators, thus the iterator needs to be recreated.
    let Ok( children ) = tree.children( index ) else {
        return Err( "Never reached.".to_string() );
    };
    let mut iterator = children.iter().skip( 2 );

    let mut pairs = HashMap::<String, String>::new();
    while let Some( selector ) = iterator.next() {
        if !check_node_type( tree, *selector, NodeType::Selector ) {
            return Err( "Selector node was not found.".to_string() );
        }
        let Ok( first ) = tree.first( *selector ) else {
            return Err( "First child of Selector node not found.".to_string() );
        };
        if !check_node_type( tree, first, NodeType::Identifier ) {
            return Err( "Identifier node was not found.".to_string() );
        }
        let Ok( first_data ) = tree.data_ref( first ) else {
            return Err( "Could not retrieve data for selector first node.".to_string() );
        };
        let Some( first_token ) = first_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
            return Err( "Failed to retrieve token for selector first node.".to_string() ) ;
        };
        let Ok( last ) = tree.last( *selector ) else {
            return Err( "Last child of Selector node not found.".to_string() );
        };
        if !check_node_type( tree, last, NodeType::Identifier ) {
            return Err( "Identifier node was not found.".to_string() );
        }
        let Ok( last_data ) = tree.data_ref( last ) else {
            return Err( "Could not retrieve data for selector last node.".to_string() );
        };
        let Some( last_token ) = last_data.first().unwrap().downcast_ref::<Rc<Token>>() else {
            return Err( "Failed to retrieve token for selector last node.".to_string() );
        };
        let name = last_token.string.to_string();
        pairs.insert( first_token.string.to_string(), name );
    }
    Ok( pairs )
}

fn plural_category( category: PluralCategory ) -> &'static str {
    match category {
        PluralCategory::Zero => "zero",
        PluralCategory::One => "one",
        PluralCategory::Two => "two",
        PluralCategory::Few => "few",
        PluralCategory::Many => "many",
        PluralCategory::Other => "other",
    }
}

fn sign_display( sign: &str ) -> Result<SignDisplay, String> {
    match sign {
        "auto" => return Ok( SignDisplay::Auto ),
        "never" => return Ok( SignDisplay::Never ),
        "always" => return Ok( SignDisplay::Always ),
        "except_zero" => return Ok( SignDisplay::ExceptZero ),
        "negative" => return Ok( SignDisplay::Negative ),
        _ => return Err( "Invalid decimal sign option.".to_string() )
    }
}

fn decimal_grouping_display( group: &str ) -> Result<options::GroupingStrategy, String> {
    match group {
        "auto" => return Ok( options::GroupingStrategy::Auto ),
        "never" => return Ok( options::GroupingStrategy::Never ),
        "always" => return Ok( options::GroupingStrategy::Always ),
        "min2" => return Ok( options::GroupingStrategy::Min2 ),
        _ => return Err( "Invalid decimal group option.".to_string() )
    }
}

fn date_length( len: &str ) -> Result<DateLength, String> {
    match len {
        "full" => return Ok( DateLength::Full ),
        "long" => return Ok( DateLength::Long ),
        "medium" => return Ok( DateLength::Medium ),
        "short" => return Ok( DateLength::Short ),
        _ => return Err( "Invalid date length option.".to_string() )
    }
}

fn time_length( len: &str ) -> Result<TimeLength, String> {
    match len {
        "full" => return Ok( TimeLength::Full ),
        "long" => return Ok( TimeLength::Long ),
        "medium" => return Ok( TimeLength::Medium ),
        "short" => return Ok( TimeLength::Short ),
        _ => return Err( "Invalid time length option.".to_string() )
    }
}

/// Decomposes an ISO 8601 date string into a `Date<Iso>` struct.
/// 
/// Supported ISO 8601 extended and basic formats:
///   YYYY-MM-DD or YYYYMMDD
///   YYYY-MM
///   YYYY
/// where:
///   YYYY refers to a zero-padded year, range of 0000 to 9999 (1 BC to 9999 AD).
///   MM refers to a zero-padded month, range of 01 to 12, and defaults to 01 when not present.
///   DD refers to a zero-padded day, range of 01 to 31, and defaults to 01 when not present.
/// 
/// Currently ISO 8601 does not allow the YYYYMM format due to historical data using the obsolete YYMMDD format.
///
/// Supported ISO 8601 expanded formats:
///   -YYYY-MM-DD
///   -YYYY-MM
///   -YYYY
///   YYYYY-MM-DD
///   YYYYY-MM
///   YYYYY
/// where:
///    refers to either + or -.
///   YYYY refers to zero-padded year with - prefix, range of -0001 to -9999 (2 BC to 10000 BC).
///   YYYYY refers to 5 or more digits with either + or - prefix, range before -9999 (10000 BC) or after 9999.
///   MM refers to a zero-padded month, range of 01 to 12, and defaults to 01 when not present.
///   DD refers to a zero-padded day, range of 01 to 31, and defaults to 01 when not present.
///
/// ICU4X `Date` supports the year to be in the range of `-2_147_483_648` to `2_147_483_647`.
/// 
/// ISO 8601 _Week_ and _Ordinal date_ formats are not supported as there are currently no methods available for 
/// ICU4X `Date<Iso>` for creating structs using the week number or the ordinal day of the year.
pub fn decompose_iso_date( string: &str ) -> Result<Date<Iso>, String> {
    let no_plus = string.trim_start_matches( '+' );
    let mut year: i32 = 0;
    let mut month: u8 = 1;
    let mut day: u8 = 1;
    if no_plus.is_empty() {
        // no year
        let Ok( date ) = Date::try_new_iso_date( year, month, day ) else {
            return Err( "Invalid date component.".to_string() )
        };
        return Ok( date );
    }
    let parts: Vec<&str> = no_plus.split( '-' ).collect();
    if parts.len() == 1 {
        // YYYYMMDD or YYYY. ISO 8601 may re-add YYYYMM in the future, once most historical data has been 
        // converted from YYMMDD.
        if let Some( slice ) = parts[ 0 ].get( ..4 ) {
            match i32::from_str( slice ) {
                Err( _ ) => return Err( "Invalid year.".to_string() ),
                Ok( result ) => year = result
            }
            // try month
            if let Some( slice ) = parts[ 0 ].get( 4..6 ) {
                match u8::from_str( slice ) {
                    Err( _ ) => return Err( "Invalid month.".to_string() ),
                    Ok( result ) => month = result
                }
                // try day
                if let Some( slice ) = parts[ 0 ].get( 6..8 ) {
                    match u8::from_str( slice ) {
                        Err( _ ) => return Err( "Invalid day.".to_string() ),
                        Ok( result ) => day = result
                    }
                }
            }
        }
    } else {
        let mut index = 0usize;
        let mut year_string = String::new();
        if parts[ 0 ].is_empty() {
            // negative dates
            year_string.push( '-' );
            index = 1;
        }
        year_string.push_str( parts[ index ] );
        match i32::from_str( &year_string ) {
            Err( _ ) => return Err( "Invalid year.".to_string() ),
            Ok( result ) => year = result
        }
        // try month
        index += 1;
        if let Some( slice ) = parts.get( index ) {
            match u8::from_str( slice ) {
                Err( _ ) => return Err( "Invalid month.".to_string() ),
                Ok( result ) => month = result
            }
            // try day
            index += 1;
            if let Some( slice ) = parts.get( index ) {
                match u8::from_str( slice ) {
                    Err( _ ) => return Err( "Invalid day.".to_string() ),
                    Ok( result ) => day = result
                }
            }
        }
    }
    match Date::try_new_iso_date( year, month, day ) {
        Err( _ ) => Err( "Invalid date component.".to_string() ),
        Ok( result ) => Ok( result )
    }
}

/// Decomposes an ISO time string into a `Time` struct.
/// 
/// Supported ISO 8601 extended and basic formats:
///   Thh:mm:ss.nnn or Thhmmss.nnn
///   Thh:mm:ss or Thhmmss
///   Thh:mm or Thhmm
///   Thh
///   T 
/// where:
///   T refers to the time separator from date. Even though required by ISO 8601, it is optional here.
///   hh refers to a zero-padded hour, range of 00 to 24 (24 used to represent last instance of the day 24:00:00).
///   mm refers to a zero-padded minute, range of 00 to 59.
///   ss refers to a zero-padded second, range of 00 to 60 (where 60 is only used to denote an added leap second).
///   nnn refers to a nanosecond, range of 000 to 999.
/// 
/// All time components not included are treated as zero.
/// 
/// Time zones are not supported by ICU4X `Time`, thus will be ignored.
/// - time zones ( Z (for UCT 00:00), +hh:mm, -hh:mm, +hhmm, -hhmm ).
///   -00:00 or -0000 are not supported by ISO 8601.

pub fn decompose_iso_time( string: &str ) -> Result<Time, String> {
    let no_t = string.trim_start_matches( 'T' );
    let no_plus = match no_t.find( '+' ) {
        None => no_t,
        Some( pos ) => &no_t[ ..pos ]
    };
    let trimmed = match no_plus.find( '-' ) {
        None => no_plus,
        Some( pos ) => &no_plus[ ..pos ]
    };
    if trimmed.is_empty() {
        return Ok( Time::new( IsoHour::zero(), IsoMinute::zero(), IsoSecond::zero(), NanoSecond::zero() ) );
    }
    let mut hour = IsoHour::zero();
    let mut minute = IsoMinute::zero();
    let mut second = IsoSecond::zero();
    let mut nano = NanoSecond::zero();
    if let Some( slice ) = trimmed.get( ..2 ) {
        match IsoHour::from_str( slice ) {
            Err( _ ) => return Err( "Invalid hour.".to_string() ),
            Ok( result ) => hour = result
        }
        // try minute
        let mut no_hour = &trimmed[ 2.. ];
        no_hour = no_hour.trim_start_matches( ':' );
        if let Some( slice ) = no_hour.get( ..2 ) {
            match IsoMinute::from_str( slice ) {
                Err( _ ) => return Err( "Invalid minute.".to_string() ),
                Ok( result ) => minute = result
            }
            // try second
            let mut no_minute = &no_hour[ 2.. ];
            no_minute = no_minute.trim_start_matches( ':' );
            if let Some( slice ) = no_minute.get( ..2 ) {
                match IsoSecond::from_str( slice ) {
                    Err( _ ) => return Err( "Invalid second.".to_string() ),
                    Ok( result ) => second = result
                }
                // try nanosecond
                let mut no_second = &no_minute[ 2.. ];
                no_second = no_second.trim_start_matches( '.' );
                match NanoSecond::from_str( no_second ) {
                    Err( _ ) => return Err( "Invalid nanosecond.".to_string() ),
                    Ok( result ) => nano = result
                }
            }
        }
    }
    Ok( Time::new( hour, minute, second, nano ) )
}

struct OptionSelectors<'a> {
    valid_plurals: Vec<&'a str>,
    calendars: Vec<&'a str>,
}

enum ComplexType {
    Plural,
    Ordinal,
    Select,
}

trait Marker {
    fn get_type( &self ) -> &str;

    fn as_any( &self ) -> &dyn Any;

    fn as_any_mut( &mut self ) -> &mut dyn Any;
}

struct Text {
     string: String,
}

impl Marker for Text {
    fn get_type( &self ) -> &str {
        "Text"
    }

    fn as_any( &self ) -> &dyn Any {
        self
    }

    fn as_any_mut( &mut self ) -> &mut dyn Any {
        self
    }
}

struct NumberSign {
    index: usize,
}

impl Marker for NumberSign {
    fn get_type( &self ) -> &str {
        "NumberSign"
    }

    fn as_any( &self ) -> &dyn Any {
        self
    }

    fn as_any_mut( &mut self ) -> &mut dyn Any {
        self
    }
}

struct PatternString {
    placeholder: String,
}

impl Marker for PatternString {
    fn get_type( &self ) -> &str {
        "PatternString"
    }

    fn as_any( &self ) -> &dyn Any {
        self
    }

    fn as_any_mut( &mut self ) -> &mut dyn Any {
        self
    }
}

struct PatternDecimal {
    placeholder: String,
    sign: Option<SignDisplay>,
    group: Option<options::GroupingStrategy>,
}

impl Marker for PatternDecimal {
    fn get_type( &self ) -> &str {
        "PatternDecimal"
    }

    fn as_any( &self ) -> &dyn Any {
        self
    }

    fn as_any_mut( &mut self ) -> &mut dyn Any {
        self
    }
}

struct PatternDateTime {
    placeholder: String,
    length_date: Option<DateLength>,
    length_time: Option<TimeLength>,
    calendar: Option<Locale>,
}

impl Marker for PatternDateTime {
    fn get_type( &self ) -> &str {
        "PatternDateTime"
    }

    fn as_any( &self ) -> &dyn Any {
        self
    }

    fn as_any_mut( &mut self ) -> &mut dyn Any {
        self
    }
}

struct PatternComplex {
    placeholder: String,
    complex: ComplexType,
    selectors: usize,
}

impl Marker for PatternComplex {
    fn get_type( &self ) -> &str {
        "PatternComplex"
    }

    fn as_any( &self ) -> &dyn Any {
        self
    }

    fn as_any_mut( &mut self ) -> &mut dyn Any {
        self
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use icu_testdata::buffer;
    use i18n_lexer::Lexer;

    #[test]
    fn plain_text() {
        fn format_string() -> Result<(), String> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "A simple plain text string.", &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens )?;
            let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let mut formatter = Formatter::try_new( &locale, &tree )?;
            let values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!( result.as_str(), "A simple plain text string.", "Strings must be the same." );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_string() {
        fn format_string() -> Result<(), String> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "Expecting a string for placeholder: {string}", &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens )?;
            let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let mut formatter = Formatter::try_new( &locale, &tree )?;
            let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
            values.insert(
                "string".to_string(),
                Box::new( PlaceholderString { string: "This is a string.".to_string() } )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "Expecting a string for placeholder: This is a string.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_plural() {
        fn format_string() -> Result<(), String> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens )?;
            let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let mut formatter = Formatter::try_new( &locale, &tree )?;
            let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
            values.insert(
                "dogs_number".to_string(),
                Box::new( PlaceholderUnsigned { number: 3 } )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "There are 3 dogs in the park.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_decimal() {
        fn format_string() -> Result<(), String> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "There is {amount decimal} kg of rice in the container.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens )?;
            let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let mut formatter = Formatter::try_new( &locale, &tree )?;
            let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
            values.insert(
                "amount".to_string(),
                Box::new( PlaceholderFloat { number: 3.678 } )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "There is 3,678 kg of rice in the container.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_decimal_with_option() {
        fn format_string() -> Result<(), String> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "There is {amount decimal sign#always} kg of rice in the container.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens )?;
            let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let mut formatter = Formatter::try_new( &locale, &tree )?;
            let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
            values.insert(
                "amount".to_string(),
                Box::new( PlaceholderFloat { number: 3.678 } )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "There is +3,678 kg of rice in the container.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_dateime() {
        fn format_string() -> Result<(), String> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "At this point in time {time date_time} the moon winked out.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens )?;
            let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let mut formatter = Formatter::try_new( &locale, &tree )?;
            let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
            values.insert(
                "time".to_string(),
                Box::new( PlaceholderDateTime {
                    date_time: DateTime::<Iso>::new(
                        Date::try_new_iso_date( 248624, 10, 6 ).ok().unwrap(),
                        Time::try_new( 5, 47, 23, 254 ).ok().unwrap()
                    ).to_any()
                } )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "At this point in time 06 Oct 248624, 05:47:23 the moon winked out.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }

    #[test]
    fn pattern_dateime_string() {
        fn format_string() -> Result<(), String> {
            let buffer_provider = Box::new( buffer() );
            let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
            let tokens = lexer.tokenise(
                "At this point in time {time date_time} the moon winked out.",
                &vec![ '{', '}', '`', '#' ]
            );
            let tree = parse( tokens )?;
            let locale = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
            let mut formatter = Formatter::try_new( &locale, &tree )?;
            let mut values = HashMap::<String, Box::<dyn PlaceholderValue>>::new();
            values.insert(
                "time".to_string(),
                Box::new( PlaceholderString { string: "+248624-10-06T05:47:23.254".to_string() } )
            );
            let result = formatter.format( &buffer_provider, &values )?;
            assert_eq!(
                result.as_str(),
                "At this point in time 06 Oct 248624, 05:47:23 the moon winked out.",
                "Strings must be the same."
            );
            Ok( () )
        }
        match format_string() {
            Err( error ) => {
                println!( "Error: {}", error );
                assert!( false );
                return;
            },
            Ok( _ ) => {}
        };
    }
}
