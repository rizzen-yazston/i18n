// This file is part of `i18n_pattern-rizzen-yazston` crate. For the terms of use, please see the file
// called LICENSE-BSD-3-Clause at the top level of the `i18n_pattern-rizzen-yazston` crate.

//! Parsing of string tokens into an Abstract Syntax Tree (AST), checking the grammar of patterns is valid.
//! The parser only does the syntactic analysis of the supplied Token vector.
//! 
//! The formatter takes the Abstract Syntax Tree (AST) that was generated by the parser and constructs a string
//! template for values to be substituted into. The formatter also does the semantic analysis of the grammar. Once a
//! string template has been constructed, it can be used multiple times by simply supplying new placeholder values when
//! executing the `format()` method. Depending on the placeholder type of the pattern, a suitable selection of the
//! available data types can be used, these include the basic `String`, integers, unsigned integers and floats. In
//! addition to these special ICU4X types are supported such as `FixedDecimal`, `Date`, `Time` and `DateTime` structs.
//! 
//! See `pattern strings.asciidoc` in `docs` of `pattern` for the pattern formatting specification.
//! 
//! # Examples
//! 
//! ```
//! use icu_provider::prelude::*;
//! use icu_locid::Locale;
//! use std::rc::Rc;
//! use i18n_lexer::{ Token, TokenType, Lexer };
//! use icu_testdata::buffer;
//! use i18n_pattern::{ parse, NodeType, Formatter, FormatterError, PlaceholderValue };
//! use std::collections::HashMap;
//! use std::error::Error;
//! 
//! fn pattern_plural() -> Result<(), Box<dyn Error>> {
//!     let buffer_provider = Box::new( buffer() );
//!     let mut lexer = Lexer::try_new( &buffer_provider ).expect( "Failed to initialise lexer." );
//!     let tokens = lexer.tokenise(
//!         "There {dogs_number plural one#one_dog other#dogs} in the park.#{dogs are # dogs}{one_dog is 1 dog}",
//!         &vec![ '{', '}', '`', '#' ]
//!     );
//!     let tree = parse( tokens ).expect( "Failed to parse tokens." );
//!     let locale: Rc<Locale> = Rc::new( "en-ZA".parse().expect( "Failed to parse language tag." ) );
//!     let language_tag = Rc::new( locale.to_string() );
//!     let mut formatter = Formatter::try_new( &language_tag, &locale, &tree )?;
//!     let mut values = HashMap::<String, PlaceholderValue>::new();
//!     values.insert(
//!         "dogs_number".to_string(),
//!         PlaceholderValue::Unsigned( 3 )
//!     );
//!     let result = formatter.format( &buffer_provider, &values )?;
//!     assert_eq!( result.as_str(), "There are 3 dogs in the park.", "Strings must be the same." );
//!     Ok( () )
//! }
//! ```

pub mod types;
pub mod parser;
pub mod formatter;
pub mod error;

pub use types::*;
pub use parser::*;
pub use formatter::*;
pub use error::*;
